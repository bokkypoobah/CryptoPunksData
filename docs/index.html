<!DOCTYPE html>
<html lang="en">
  <head>
    <title>CryptoPunksData</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="CryptoPunksData (c) Bok Consulting Pty Ltd 2023" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="globals.js"></script>
    <script src="deploymentData.js"></script>
    <script src="punkAttributes.js"></script>
    <script src="txparser.js"></script>

    <link rel="apple-touch-icon" sizes="57x57" href="/images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/punk_3636.png" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">CryptoPunksData</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings()" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Welcome screen with info'">Home</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings()" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'View Activity'">Activity</b-nav-item>
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings()" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'View/sync Pair'">Pair</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 3; saveSettings()" :active="settings.tabIndex == 3" active-class="active" v-b-popover.hover="'View/edit ERC-20 tokens'">Tokens</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 4; saveSettings()" :active="settings.tabIndex == 4" active-class="active" v-b-popover.hover="'Execute raw Chadex transactions'">Raw</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 5; saveSettings()" :active="settings.tabIndex == 5" active-class="active" v-b-popover.hover="'View info'">Info</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 5; saveSettings()" :active="settings.tabIndex == 5" active-class="active" v-b-popover.hover="'View/edit my accounts'">Accounts</b-nav-item> -->
            <b-avatar v-if="coinbase && coinbase != ensOrAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensOrAddress(coinbase)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar>
            <b-button size="sm" variant="outline-primary" class="ml-1" @click="processIt('connect'); syncAll();" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? ensOrAddress(coinbase, 16) : 'Connect' }}</b-button>
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Revoke permissions when not required, at this early stage.
          </b-alert>
          <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase || chainId != '1'">
            <b-card-text>
              Please install the MetaMask extension, connect to the Ethereum Mainnet and refresh this page. Then click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <b-modal id="modal-tx-details" hide-footer size="lg">
            <template #modal-title>
              <font size="-1">Tx {{ modalTxDetails.item.txHash }}</font>
              <b-button size="sm" @click="copyToClipboard(modalTxDetails.item.txHash);" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Copy to clipboard'"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
              <b-link size="sm" :href="'https://sepolia.etherscan.io/tx/' + modalTxDetails.item.txHash" target="_blank" variant="link" class="m-0 p-0" v-b-popover.hover.top="'View in etherscan.io'">
                <b-img rounded="0" width="16px" height="16px" src="images/etherscan-logo-circle.svg" blank-color="#777" target="_blank"></b-img>
              </b-link>
            </template>
            <b-form-group v-if="modalTxDetails.item" label="Block Number:" label-for="modal-tx-details-blocknumber" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-tx-details-blocknumber" :value="modalTxDetails.item.blockNumber" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group v-if="modalTxDetails.item" label="Timestamp:" label-for="modal-tx-details-timestamp" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-tx-details-timestamp" :value="formatTimestamp(modalTxDetails.item.timestamp)" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group v-if="modalTxDetails.tx" label="From:" label-for="modal-tx-details-from" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <template slot="description">
                <div v-if="ensOrAddress(modalTxDetails.tx.from) != modalTxDetails.tx.from">
                  {{ modalTxDetails.tx.from }}
                </div>
              </template>
              <b-input-group size="sm" class="w-75">
                <b-form-input type="text" readonly size="sm" id="modal-tx-details-from" :value="ensOrAddress(modalTxDetails.tx.from)"></b-form-input>
                <b-input-group-append class="ml-1">
                  <b-button size="sm" @click="copyToClipboard(modalTxDetails.tx.from);" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Copy to clipboard'"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                  <b-link size="sm" :href="'https://sepolia.etherscan.io/address/' + modalTxDetails.tx.from" target="_blank" variant="link" class="m-0 ml-1 p-0" v-b-popover.hover.top="'View in etherscan.io'">
                    <b-img rounded="0" width="16px" height="16px" src="images/etherscan-logo-circle.svg" blank-color="#777" target="_blank"></b-img>
                  </b-link>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalTxDetails.tx" label="To:" label-for="modal-tx-details-to" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <template slot="description">
                <div v-if="ensOrAddress(modalTxDetails.tx.to) != modalTxDetails.tx.to">
                  {{ modalTxDetails.tx.to }}
                </div>
              </template>
              <b-input-group size="sm" class="w-75">
                <b-form-input type="text" readonly size="sm" id="modal-tx-details-to" :value="ensOrAddress(modalTxDetails.tx.to)"></b-form-input>
                <b-input-group-append class="ml-1">
                  <b-button size="sm" @click="copyToClipboard(modalTxDetails.tx.to);" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Copy to clipboard'"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                  <b-link size="sm" :href="'https://sepolia.etherscan.io/address/' + modalTxDetails.tx.to" target="_blank" variant="link" class="m-0 ml-1 p-0" v-b-popover.hover.top="'View in etherscan.io'">
                    <b-img rounded="0" width="16px" height="16px" src="images/etherscan-logo-circle.svg" blank-color="#777" target="_blank"></b-img>
                  </b-link>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>

            <span v-if="modalTxDetails.tradeInputs" v-for="(tradeInput, tradeInputIndex) in modalTxDetails.tradeInputs" :key="tradeInputIndex">
                <b-form-group :label="'Action[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.action == 0 ? 'Fill' : (tradeInput.action == 1 ? 'Fill Or Kill' : 'Fill And Add Order')" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Buy/Sell[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.buySell == 0 ? 'Buy' : 'Sell'" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Base[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.base" class="w-75"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Quote[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.quote" class="w-75"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Price[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.price" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Target Price[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.targetPrice" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Expiry[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.expiry" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Tokens[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.tokens" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Skip Check[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.skipCheck ? 'Yes' : 'No'" class="w-50"></b-form-input>
                </b-form-group>

            </span>

            <div>
              <pre>
{{ modalTxDetails }}
              </pre>
            </div>
          </b-modal>

          <!-- <b-modal id="modal-accounts-import" hide-footer size="lg">
            <template #modal-title>
              Import Accounts
            </template>
            <b-form-group label="Restore:" label-for="restore-from-backup-browse" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Select backup .tsv file from your local computer to restore'" class="mx-0 my-1 p-0">
              <b-form-file size="sm" id="restore-from-backup-browse" v-model="restoreFile" @change="backupFilesChange($event.target.name, $event.target.files)" accept=".tsv" class="w-75"></b-form-file>
            </b-form-group>
            <b-form-group v-if="restoreAddresses" label="Loaded data:" label-for="restore-from-backup-data" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Only valid unique addresses will be imported'" class="mx-0 my-1 p-0">
              <font v-if="restoreAddresses" size="-2">
                <b-table small id="restore-from-backup-data" fixed striped sticky-header="200px" :fields="accountsImportAddressesFields" :items="restoreAddresses" head-variant="light">
                </b-table>
              </font>
            </b-form-group>
            <b-form-group label="" label-for="restore-from-backup" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Restore from backup file. Adjust Sync and Include settings and re-synced'" class="mx-0 my-1 p-0">
              <b-button size="sm" id="restore-from-backup" :disabled="!restoreAddresses || restoreAddresses.length == 0" @click="restoreFromBackup()" variant="primary">Restore</b-button>
            </b-form-group>
          </b-modal> -->

          <!-- <b-modal id="modal-token-details" hide-footer size="lg">
            <template #modal-title>
              ERC-20 Token {{ modalTokenDetails.address }}
              <b-button size="sm" @click="copyToClipboard(modalTokenDetails.address);" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Copy to clipboard'"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
              <b-link size="sm" :href="'https://sepolia.etherscan.io/token/' + modalTokenDetails.address + '?a=' + coinbase" target="_blank" variant="link" class="m-0 p-0" v-b-popover.hover.top="'View in etherscan.io'">
                <b-img rounded="0" width="16px" height="16px" src="images/etherscan-logo-circle.svg" blank-color="#777" target="_blank"></b-img>
              </b-link>
            </template>
            <b-form-group label="Symbol:" label-for="modal-token-details-symbol" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-token-details-symbol" :value="modalTokenDetails.symbol" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Name:" label-for="modal-token-details-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-token-details-name" :value="sanitise(modalTokenDetails.name)" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Decimals:" label-for="modal-token-details-decimals" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-token-details-decimals" :value="modalTokenDetails.decimals" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Balance:" label-for="modal-token-details-balance" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Get some test tokens in the Tokens tab" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-token-details-balance" :value="formatERC20(modalTokenDetails.balance, modalTokenDetails.decimals)" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Allowance:" label-for="modal-token-details-allowance" label-size="sm" label-cols-sm="3" label-align-sm="right"  description="Allowance to chadex smart contract. Update this in the Tokens tab" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-token-details-allowance" :value="formatERC20(modalTokenDetails.allowance, modalTokenDetails.decimals)" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Total Supply:" label-for="modal-token-details-totalsupply" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-token-details-totalsupply" :value="formatERC20(modalTokenDetails.totalSupply, modalTokenDetails.decimals)" class="w-50"></b-form-input>
            </b-form-group>
          </b-modal> -->

          <!-- <b-modal id="modal-maker-order" hide-footer size="lg">
            <template #modal-title>
              Maker Order
            </template>
            <b-form-group label="Order Type:" label-for="modal-maker-order-ordertype" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-maker-order-ordertype" :value="modalMakerOrder.buySell == 0 ? 'BUY' : 'SELL'" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Price:" label-for="modal-maker-order-price" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-maker-order-price" :value="formatERC20(modalMakerOrder.price, 12)" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Pair Key:" label-for="modal-maker-order-pairkey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-maker-order-pairkey" :value="settings.pairTable.selectedPair" class="w-100"></b-form-input>
            </b-form-group>
            <b-form-group label="Order Key:" label-for="modal-maker-order-orderkey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-maker-order-orderkey" :value="modalMakerOrder.orderKey" class="w-100"></b-form-input>
            </b-form-group>
            <b-form-group label="Maker:" label-for="modal-maker-order-maker" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <template slot="description">
                <div v-if="ensOrAddress(modalMakerOrder.makerIndex) != indexToAddress[modalMakerOrder.makerIndex]">
                  {{ indexToAddress[modalMakerOrder.makerIndex] }}
                </div>
              </template>
              <b-input-group size="sm" class="w-75">
                <b-form-input type="text" readonly size="sm" id="modal-maker-order-maker" :value="ensOrAddress(modalMakerOrder.makerIndex)"></b-form-input>
                <b-input-group-append class="ml-1">
                  <b-button size="sm" @click="copyToClipboard(indexToAddress[modalMakerOrder.makerIndex]);" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Copy to clipboard'"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                  <b-link size="sm" :href="'https://sepolia.etherscan.io/address/' + indexToAddress[modalMakerOrder.makerIndex]" target="_blank" variant="link" class="m-0 ml-1 p-0" v-b-popover.hover.top="'View in etherscan.io'">
                    <b-img rounded="0" width="16px" height="16px" src="images/etherscan-logo-circle.svg" blank-color="#777" target="_blank"></b-img>
                  </b-link>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="Expiry:" label-for="modal-maker-order-expiry" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-maker-order-expiry" :value="formatExpiry(modalMakerOrder.expiry)" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group :label="getSelectedBaseSymbol +' :'" label-for="modal-maker-order-originaltokens" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-maker-order-originaltokens" :value="formatERC20(modalMakerOrder.originalTokens)" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group :label="'Available ' + getSelectedBaseSymbol + ':'" label-for="modal-maker-order-tokens" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="'Taking into maker\'s ' + (modalMakerOrder.buySell == 0 ? getSelectedQuoteSymbol : getSelectedBaseSymbol) + ' account balance and allowance to Chadex'" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-maker-order-tokens" :value="formatERC20(modalMakerOrder.tokens)" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group v-if="indexToAddress[modalMakerOrder.makerIndex] == coinbase" label="" label-for="modal-maker-order-cancel" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="warning" class="ml-1" @click="cancelOrder();" v-b-popover.hover.bottom="'Cancel order'">Cancel Order</b-button>
            </b-form-group>
          </b-modal> -->

          <!-- 0:Home -->
          <b-card v-if="coinbase && settings.tabIndex == 0" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Home
            </template>
            <b-card-text class="m-0 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-1">
                  <b-button size="sm" :pressed.sync="settings.showFilter" @click="saveSettings" variant="link" v-b-popover.hover.top="'Show filter'"><span v-if="settings.showFilter"><b-icon-layout-sidebar-inset shift-v="+1" font-scale="1.0"></b-icon-layout-sidebar-inset></span><span v-else><b-icon-layout-sidebar shift-v="+1" font-scale="1.0"></b-icon-layout-sidebar></span></b-button>
                </div>
                <div v-if="Object.keys(settings.filters).length > 0" class="mt-0 pr-1">
                  <b-button size="sm" @click="resetFilters();" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Reset filters'">
                    <b-iconstack shift-v="-4" font-scale="1">
                      <b-icon stacked icon="funnel-fill" variant="info" scale="1"></b-icon>
                      <b-icon stacked icon="x" variant="danger" scale="1.3"></b-icon>
                    </b-iconstack>
                  </b-button>
                </div>
                <!-- <div class="mt-0 pr-1">
                  <b-form-input type="text" size="sm" v-model.trim="settings.pairsTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Base or quote symbol and name filter'" placeholder="ðŸ” sym/name regex" style="min-width: 8.0rem;"></b-form-input>
                </div> -->
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="!sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="syncCryptoPunksData" variant="primary" v-b-popover.hover.top="'Sync CryptoPunksData. This will take ~6 minutes initially, and ~10 seconds subsequently'">Sync</b-button>
                </div>
                <div class="mt-1" style="width: 350px;">
                  <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'{processed blocked number}/{latest block number}. Click the button on the right to stop this process. This process can be continued later'">
                    <b-progress-bar :value="sync.completed">
                      {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                    </b-progress-bar>
                  </b-progress>
                </div>
                <div class="ml-0 mt-1">
                  <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.punksTable.sortOption" @change="saveSettings" :options="punksSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
                </div>
                <div class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.top="'# tokens'">{{ filteredSortedPunks.length + '/' + punkAttributes.length }}</font>
                </div>
                <div class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.punksTable.currentPage" @input="saveSettings" :total-rows="filteredSortedPunks.length" :per-page="settings.punksTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.punksTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Yeah. Page size'"></b-form-select>
                </div>
              </div>

              <b-row class="m-0 p-0">
                <b-col v-if="settings.showFilter" cols="2" class="m-0 p-0 border-0">
                  <b-card no-header no-body class="m-0 p-0 border-0">
                    <!-- <b-card-body class="m-0 p-1" style="flex-grow: 1; max-height: 1500px; overflow-y: auto;"> -->
                    <b-card-body class="m-0 px-2 py-1" style="flex-grow: 1; max-height: 1500px; overflow-y: auto;">
                      <div v-for="punkAttribute of punkAttributesWithTokenIds">
                        <b-card header-class="m-0 px-2 pt-2 pb-0" body-class="p-0" class="m-0 p-0 border-0">
                          <template #header>
                            <span variant="secondary" class="small truncate">
                              {{ slugToTitle(punkAttribute.attributeType) }}
                            </span>
                          </template>
                        </b-card>
                        <font size="-2">
                          <b-table small fixed striped sticky-header="200px" :fields="punkAttributesFields" :items="punkAttribute.attributeList" head-variant="light">
                            <template #cell(select)="data">
                              <b-form-checkbox size="sm" :checked="(settings.filters[punkAttribute.attributeType] && settings.filters[punkAttribute.attributeType][data.item.attribute]) ? 1 : 0" value="1" @change="filterChanged(punkAttribute.attributeType, data.item.attribute)"></b-form-checkbox>
                            </template>
                            <template #cell(attributeOption)="data">
                              {{ slugToTitle(data.item.attribute) }}
                            </template>
                            <template #cell(attributeTotal)="data">
                              {{ data.item.punks.length }}
                            </template>
                          </b-table>
                        </font>
                      </div>
                    </b-card-body>
                  </b-card>
                </b-col>
                <b-col class="m-0 p-0 pl-1">
                  <!-- <b-table small fixed striped responsive hover selectable select-mode="single" @row-selected="pairsRowSelected" :fields="pairsFields" :items="pagedFilteredSortedPairs" show-empty empty-html="Click Sync above to retrieve existing pairs" head-variant="light" class="mx-0 my-1"> -->
                  <b-table small fixed striped responsive hover :fields="punksFields" :items="pagedFilteredSortedPunks" show-empty empty-html="Click Sync above to retrieve punk history" head-variant="light" class="mx-0 my-1">
                    <template #cell(punkId)="data">
                      <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + data.item.punkId" v-b-popover.hover.bottom="'View in original website'" target="_blank">
                        {{ data.item.punkId }}
                      </b-link>
                    </template>
                    <template #cell(image)="data">
                      <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + data.item.punkId" v-b-popover.hover.bottom="'View in original website'" target="_blank">
                        <b-img-lazy width="100%" :src="'images/punks/punk' + data.item.punkId.toString().padStart(4, '0') + '.png'" style="background-color: #638596"/>
                      </b-link>
                    </template>
                    <template #cell(attribute)="data">
                      <span v-for="(attribute, attributeIndex) in data.item.attributes" v-bind:key="attributeIndex">
                        <!-- {{ /*slugToTitle(attribute.trait_type) + ':' +*/ slugToTitle(attribute.value) }} -->
                        <b-badge size="sm" pill variant="light" v-b-popover.hover.bottom="slugToTitle(attribute.trait_type)" class="mr-1">{{ slugToTitle(attribute.value) }}</b-badge>
                      </span>
                    </template>
                  </b-table>
                </b-col>
              </b-row>
            </b-card-text>
          </b-card>


          <!-- 1:Activity -->
          <b-card v-if="coinbase && settings.tabIndex == 1" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Activity
            </template>
            <b-card-text class="m-0 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-1">
                  <b-button size="sm" :pressed.sync="settings.showFilter" @click="saveSettings" variant="link" v-b-popover.hover.top="'Show filter'"><span v-if="settings.showFilter"><b-icon-layout-sidebar-inset shift-v="+1" font-scale="1.0"></b-icon-layout-sidebar-inset></span><span v-else><b-icon-layout-sidebar shift-v="+1" font-scale="1.0"></b-icon-layout-sidebar></span></b-button>
                </div>
                <div v-if="Object.keys(settings.filters).length > 0" class="mt-0 pr-1">
                  <b-button size="sm" @click="resetFilters();" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Reset filters'">
                    <b-iconstack shift-v="-4" font-scale="1">
                      <b-icon stacked icon="funnel-fill" variant="info" scale="1"></b-icon>
                      <b-icon stacked icon="x" variant="danger" scale="1.3"></b-icon>
                    </b-iconstack>
                  </b-button>
                </div>
                <!-- <div class="mt-0 pr-1">
                  <b-form-input type="text" size="sm" v-model.trim="settings.pairsTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Base or quote symbol and name filter'" placeholder="ðŸ” sym/name regex" style="min-width: 8.0rem;"></b-form-input>
                </div> -->
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="!sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="syncCryptoPunksData" variant="primary" v-b-popover.hover.top="'Sync CryptoPunksData. This will take ~6 minutes initially, and ~10 seconds subsequently'">Sync</b-button>
                </div>
                <div class="mt-1" style="width: 350px;">
                  <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'{processed blocked number}/{latest block number}. Click the button on the right to stop this process. This process can be continued later'">
                    <b-progress-bar :value="sync.completed">
                      {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                    </b-progress-bar>
                  </b-progress>
                </div>
                <div class="ml-0 mt-1">
                  <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.activityTable.sortOption" @change="saveSettings" :options="activitySortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
                </div>
                <div class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.top="'# events'">{{ filteredSortedActivity.length + '/' + Object.keys(txs).length }}</font>
                </div>
                <div class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.activityTable.currentPage" @input="saveSettings" :total-rows="filteredSortedActivity.length" :per-page="settings.activityTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.activityTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Yeah. Page size'"></b-form-select>
                </div>
              </div>
              <b-row class="m-0 p-0">
                <b-col v-if="settings.showFilter" cols="2" class="m-0 p-0 border-0">
                  <b-card no-header no-body class="m-0 p-0 border-0">
                    <!-- <b-card-body class="m-0 p-1" style="flex-grow: 1; max-height: 1500px; overflow-y: auto;"> -->
                    <b-card-body class="m-0 px-2 py-1" style="flex-grow: 1; max-height: 1500px; overflow-y: auto;">
                      <div v-for="punkAttribute of punkAttributesWithTokenIds">
                        <b-card header-class="m-0 px-2 pt-2 pb-0" body-class="p-0" class="m-0 p-0 border-0">
                          <template #header>
                            <span variant="secondary" class="small truncate">
                              {{ slugToTitle(punkAttribute.attributeType) }}
                            </span>
                          </template>
                        </b-card>
                        <font size="-2">
                          <b-table small fixed striped sticky-header="200px" :fields="punkAttributesFields" :items="punkAttribute.attributeList" head-variant="light">
                            <template #cell(select)="data">
                              <b-form-checkbox size="sm" :checked="(settings.filters[punkAttribute.attributeType] && settings.filters[punkAttribute.attributeType][data.item.attribute]) ? 1 : 0" value="1" @change="filterChanged(punkAttribute.attributeType, data.item.attribute)"></b-form-checkbox>
                            </template>
                            <template #cell(attributeOption)="data">
                              {{ slugToTitle(data.item.attribute) }}
                            </template>
                            <template #cell(attributeTotal)="data">
                              {{ data.item.punks.length }}
                            </template>
                          </b-table>
                        </font>
                      </div>
                    </b-card-body>
                  </b-card>
                </b-col>
                <b-col class="m-0 p-0 pl-1">
                  <b-table small fixed striped responsive hover :items="pagedFilteredSortedActivity" show-empty empty-html="Click Sync above to retrieve punk activity" head-variant="light" class="mx-0 my-1">
                  </b-table>
                  <!-- <b-table small fixed striped responsive hover :fields="activityFields" :items="pagedFilteredSortedActivity" show-empty empty-html="Click Sync above to retrieve punk history" head-variant="light" class="mx-0 my-1">
                    <template #cell(punkId)="data">
                      <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + data.item.punkId" v-b-popover.hover.bottom="'View in original website'" target="_blank">
                        {{ data.item.punkId }}
                      </b-link>
                    </template>
                    <template #cell(image)="data">
                      <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + data.item.punkId" v-b-popover.hover.bottom="'View in original website'" target="_blank">
                        <b-img-lazy width="100%" :src="'images/punks/punk' + data.item.punkId.toString().padStart(4, '0') + '.png'" style="background-color: #638596"/>
                      </b-link>
                    </template>
                    <template #cell(attribute)="data">
                      <span v-for="(attribute, attributeIndex) in data.item.attributes" v-bind:key="attributeIndex">
                        <b-badge size="sm" pill variant="light" v-b-popover.hover.bottom="slugToTitle(attribute.trait_type)" class="mr-1">{{ slugToTitle(attribute.value) }}</b-badge>
                      </span>
                    </template>
                  </b-table> -->
                </b-col>
              </b-row>
            </b-card-text>
          </b-card>

          <!-- 1:PAIRS -->
          <b-card v-if="coinbase && settings.tabIndex == 10000" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Pairs
            </template>
            <b-card-text class="m-0 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-0 pr-1">
                  <b-form-input type="text" size="sm" v-model.trim="settings.pairsTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Base or quote symbol and name filter'" placeholder="ðŸ” sym/name regex" style="min-width: 8.0rem;"></b-form-input>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="false && !sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="syncPairs('pairs')" variant="primary" v-b-popover.hover.top="'Sync Pairs'">Sync</b-button>
                </div>
                <div class="mt-1" style="width: 250px;">
                  <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'Click the button on the right to stop. This process can be continued later'">
                    <b-progress-bar :value="sync.completed">
                      {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                    </b-progress-bar>
                  </b-progress>
                </div>
                <div class="ml-0 mt-1">
                  <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <!-- <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.pairsTable.sortOption" @change="saveSettings" :options="pairsSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
                </div> -->
                <div class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.top="'# tokens'">{{ filteredSortedPairs.length + '/' + Object.keys(pairs).length }}</font>
                </div>
                <div class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.pairsTable.currentPage" @input="saveSettings" :total-rows="filteredSortedAccounts.length" :per-page="settings.pairsTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.pairsTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Yeah. Page size'"></b-form-select>
                </div>
              </div>
              <b-table small fixed striped responsive hover selectable select-mode="single" @row-selected="pairsRowSelected" :fields="pairsFields" :items="pagedFilteredSortedPairs" show-empty empty-html="Click Sync above to retrieve existing pairs" head-variant="light" class="mx-0 my-1">
                <template #cell(baseSymbol)="data">
                  <b-link @click="showModalTokenDetails(data.item.baseIndex);">{{ sanitise(data.item.baseSymbol) }}</b-link>
                </template>
                <template #cell(baseName)="data">
                  {{ sanitise(data.item.baseName) }}
                </template>
                <template #cell(quoteSymbol)="data">
                  <b-link @click="showModalTokenDetails(data.item.quoteIndex);">{{ sanitise(data.item.quoteSymbol) }}</b-link>
                </template>
                <template #cell(quoteName)="data">
                  {{ sanitise(data.item.quoteName) }}
                </template>
                <template #cell(bestBidAmount)="data">
                  <div v-if="data.item.bestBuyOrder.tokens > 0">
                    {{ formatERC20(data.item.bestBuyOrder.tokens, data.item.baseDecimals) }}
                  </div>
                </template>
                <template #cell(bestBid)="data">
                  <div v-if="data.item.bestBuyOrder.price > 0">
                    {{ formatERC20(data.item.bestBuyOrder.price, 12) }}
                  </div>
                </template>
                <template #cell(bestOffer)="data">
                  <div v-if="data.item.bestSellOrder.price > 0">
                    {{ formatERC20(data.item.bestSellOrder.price, 12, data.item.baseDecimals) }}
                  </div>
                </template>
                <template #cell(bestOfferAmount)="data">
                  <div v-if="data.item.bestSellOrder.tokens > 0">
                    {{ formatERC20(data.item.bestSellOrder.tokens, 18) }}
                  </div>
                </template>
              </b-table>
            </b-card-text>
          </b-card>

          <!-- 2:PAIR -->
          <b-card v-if="coinbase && settings.tabIndex == 2000" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Pair
              <!-- <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-0 pr-2">
                  Pair
                </div>
                <div class="mt-0 pr-1">
                  <b-form-select size="sm" v-model="settings.pairTable.selectedPair" @change="saveSettings()" :options="pairsOptions"></b-form-select>
                </div> -->
            </template>
            <b-card-text class="m-0 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-0 pr-1">
                  <b-form-select size="sm" v-model="settings.pairTable.selectedPair" @change="saveSettings(); syncAll();" :options="pairsOptions"></b-form-select>
                </div>
                <!-- <div class="mt-0 pr-1">
                  <b-form-input type="text" size="sm" v-model.trim="settings.pairsTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Base or quote symbol and name filter'" placeholder="ðŸ” sym/name regex" style="min-width: 8.0rem;"></b-form-input>
                </div> -->
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="false && !sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="syncPairs('pair')" variant="primary" v-b-popover.hover.top="'Sync selected pair'">Sync</b-button>
                </div>
                <div class="mt-1" style="width: 250px;">
                  <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'Click the button on the right to stop. This process can be continued later'">
                    <b-progress-bar :value="sync.completed">
                      {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                    </b-progress-bar>
                  </b-progress>
                </div>
                <div class="ml-0 mt-1">
                  <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <!-- <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.pairsTable.sortOption" @change="saveSettings" :options="pairsSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
                </div> -->
                <!-- <div class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.top="'# tokens'">{{ filteredSortedPairs.length + '/' + Object.keys(pairs).length }}</font>
                </div> -->
                <!-- <div class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.pairsTable.currentPage" @input="saveSettings" :total-rows="filteredSortedAccounts.length" :per-page="settings.pairsTable.pageSize" style="height: 0;"></b-pagination>
                </div> -->
                <!-- <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.pairsTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Yeah. Page size'"></b-form-select>
                </div> -->
              </div>
              <!-- <b-table small fixed striped responsive hover :fields="pairFields" :items="pagedFilteredSortedPair" show-empty empty-html="Click Sync above to retrieve existing pairs" head-variant="light" class="mx-0 my-1"> -->
              <b-row class="m-0 p-0">
                <b-col class="ml-0 mr-0 pl-0 pr-1">
                  <b-table small fixed striped responsive hover selectable select-mode="single" selected-variant="primary" @row-selected="pairBuyRowSelected" :fields="pairBuyOrdersFields" :items="pagedFilteredSortedPairBuyOrders" show-empty empty-html="Loading" head-variant="light" class="mx-0 my-1">
                    <template #head(tokens)="data">
                      {{ getSelectedBaseSymbol }}
                    </template>
                    <template #cell(price)="data">
                      {{ formatERC20(data.item.price, 12) }}
                    </template>
                    <template #cell(tokens)="data">
                      {{ formatERC20(data.item.tokens, 18) }}
                    </template>
                    <template #cell(expiry)="data">
                      {{ formatExpiryShort(data.item.expiry) }}
                    </template>
                    <template #cell(maker)="data">
                      <b-link @click="showModalMakerOrder(0, data.item);">{{ ensOrAddress(data.item.makerIndex, 16) }}</b-link>
                    </template>
                  </b-table>
                </b-col>
                <b-col class="ml-0 mr-0 pl-1 pr-0">
                  <b-table small fixed striped responsive hover selectable select-mode="single" selected-variant="primary" @row-selected="pairSellRowSelected" :fields="pairSellOrdersFields" :items="pagedFilteredSortedPairSellOrders" show-empty empty-html="Loading" head-variant="light" class="mx-0 my-1">
                    <template #head(tokens)="data">
                      {{ getSelectedBaseSymbol }}
                    </template>
                    <template #cell(price)="data">
                      {{ formatERC20(data.item.price, 12) }}
                    </template>
                    <template #cell(tokens)="data">
                      {{ formatERC20(data.item.tokens, 18) }}
                    </template>
                    <template #cell(expiry)="data">
                      {{ formatExpiryShort(data.item.expiry) }}
                    </template>
                    <template #cell(maker)="data">
                      <b-link @click="showModalMakerOrder(1, data.item);">{{ ensOrAddress(data.item.makerIndex, 16) }}</b-link>
                    </template>
                  </b-table>
                </b-col>
              </b-row>

              <b-row class="m-0 p-0">
                <b-col class="ml-0 mr-0 pl-0 pr-1">
                  <b-card no-body no-header bg-variant="light" class="m-0 p-0 w-100">
                    <b-card-body class="m-1 p-1">
                      <b-form-group :label="'Sell ' + getSelectedBaseSymbol + ':'" label-for="sell-tokens" :state="checkValidTokens(sell.tokens)" :invalid-feedback="messages.invalidInputTokens" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="sell-tokens" v-model.trim="sell.tokens" :state="checkValidTokens(sell.tokens)" v-b-popover.hover="'Enter amount of ' + getSelectedBaseSymbol + '. Up to 18 whole numbers and 24 decimal places'" class="w-50"></b-form-input>
                      </b-form-group>
                      <b-form-group :label="'Buy ' + getSelectedQuoteSymbol + ':'" label-for="sell-quotetokens" :state="checkValidTokens(sell.quoteTokens)" :invalid-feedback="messages.invalidInputTokens" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="sell-quotetokens" v-model.trim="sell.quoteTokens" :state="checkValidTokens(sell.quoteTokens)" v-b-popover.hover="'Enter amount of ' + getSelectedQuoteSymbol + '. Up to 18 whole numbers and 24 decimal places'" class="w-50"></b-form-input>
                      </b-form-group>
                      <b-form-group label="Min Price:" label-for="sell-price" :state="checkValidPrice(sell.price)" :invalid-feedback="messages.invalidInputPrice" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="sell-price" v-model.trim="sell.price" :state="checkValidPrice(sell.price)" v-b-popover.hover="'Up to 12 whole numbers and 12 decimal places'" class="w-50"></b-form-input>
                      </b-form-group>
                      <b-form-group label="Max Average Price:" label-for="sell-targetprice" :state="checkValidPrice(sell.targetPrice)" :invalid-feedback="messages.invalidInputPrice" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="sell-targetprice" v-model.trim="sell.targetPrice" :state="checkValidPrice(sell.targetPrice)" v-b-popover.hover="'Up to 12 whole numbers and 12 decimal places. Only required when filling orders'" class="w-50"></b-form-input>
                      </b-form-group>
                      <b-form-group label="Action:" label-for="sell-action" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-select size="sm" v-model="sell.action" :options="actionOptions" v-b-popover.hover.top="'Yeah. Action'" class="w-50"></b-form-select>
                      </b-form-group>
                      <b-form-group v-if="sell.action == 2" label="Expiry:" label-for="sell-expiry" label-size="sm" label-cols-sm="3" label-align-sm="right"  description="Unix time. '0' for no expiry" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="sell-expiry" v-model.trim="sell.expiry" placeholder="e.g. '1704027599' for 23:59:59 31/12/2023" class="w-25"></b-form-input>
                      </b-form-group>
                      <b-form-group label="" label-for="sell-submit" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Fill in fields above first!" class="mx-0 my-1 p-0">
                        <b-button size="sm" :disabled="false" id="sell-submit" @click="executeSell()" variant="warning">SELL</b-button>
                      </b-form-group>
                    </b-card-body>
                  </b-card>
                </b-col>
                <b-col class="ml-0 mr-0 pl-1 pr-0">
                  <b-card no-body no-header bg-variant="light" class="m-0 p-0 w-100">
                    <b-card-body class="m-1 p-1">
                      <b-form-group :label="'Buy ' + getSelectedBaseSymbol + ':'" label-for="buy-tokens" :state="checkValidTokens(buy.tokens)" :invalid-feedback="messages.invalidInputTokens" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="buy-tokens" v-model.trim="buy.tokens" :state="checkValidTokens(buy.tokens)"  v-b-popover.hover="'Enter amount of ' + getSelectedBaseSymbol + '. Up to 18 whole numbers and 24 decimal places'" class="w-50"></b-form-input>
                      </b-form-group>
                      <b-form-group :label="'Sell ' + getSelectedQuoteSymbol + ':'" label-for="buy-quotetokens" :state="checkValidTokens(buy.quoteTokens)" :invalid-feedback="messages.invalidInputTokens" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="buy-quotetokens" v-model.trim="buy.quoteTokens" :state="checkValidTokens(buy.quoteTokens)" v-b-popover.hover="'Enter amount of ' + getSelectedQuoteSymbol + '. Up to 18 whole numbers and 24 decimal places'" class="w-50"></b-form-input>
                      </b-form-group>
                      <b-form-group label="Max Price:" label-for="buy-price" :state="checkValidPrice(buy.price)" :invalid-feedback="messages.invalidInputPrice" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="buy-price" v-model.trim="buy.price" :state="checkValidPrice(buy.price)" v-b-popover.hover="'Up to 12 whole numbers and 12 decimal places'" class="w-50"></b-form-input>
                      </b-form-group>
                      <b-form-group label="Min Average Price:" label-for="buy-targetprice" :state="checkValidPrice(buy.targetPrice)" :invalid-feedback="messages.invalidInputPrice" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="buy-targetprice" v-model.trim="buy.targetPrice" :state="checkValidPrice(buy.targetPrice)" v-b-popover.hover="'Up to 12 whole numbers and 12 decimal places. Only required when filling orders'" class="w-50"></b-form-input>
                      </b-form-group>
                      <b-form-group label="Action:" label-for="buy-action" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-form-select size="sm" v-model="buy.action" :options="actionOptions" v-b-popover.hover.top="'Yeah. Action'" class="w-50"></b-form-select>
                      </b-form-group>
                      <b-form-group v-if="buy.action == 2" label="Expiry:" label-for="buy-expiry" label-size="sm" label-cols-sm="3" label-align-sm="right"  description="Unix time. '0' for no expiry" class="mx-0 my-1 p-0">
                        <b-form-input type="text" size="sm" id="buy-expiry" v-model.trim="buy.expiry" placeholder="e.g. '1704027599' for 23:59:59 31/12/2023" class="w-25"></b-form-input>
                      </b-form-group>
                      <b-form-group label="" label-for="buy-submit" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Fill in fields above first!" class="mx-0 my-1 p-0">
                        <b-button size="sm" :disabled="false" id="buy-submit" @click="executeBuy()" variant="warning">BUY</b-button>
                      </b-form-group>
                    </b-card-body>
                  </b-card>
                </b-col>
              </b-row>
            </b-card-text>
          </b-card>

          <!-- 1&2:HISTORY -->
          <b-card v-if="coinbase && (settings.tabIndex == 1000 || settings.tabIndex == 2000)" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              History
              <!-- <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-0 pr-2">
                  Pair
                </div>
                <div class="mt-0 pr-1">
                  <b-form-select size="sm" v-model="settings.pairTable.selectedPair" @change="saveSettings()" :options="pairsOptions"></b-form-select>
                </div> -->
            </template>
            <b-card-text class="m-0 p-0">
              <!-- <b-table small fixed striped responsive hover :fields="pairHistoryFields" :items="pagedFilteredSortedPairHistory" show-empty empty-html="TODO: History" head-variant="light" class="mx-0 my-1"> -->
              <b-table small fixed striped responsive hover :items="pagedFilteredSortedPairHistory" show-empty empty-html="TODO: History" head-variant="light" class="mx-0 my-0">
                <template #cell(timestamp)="data">
                  <b-link @click="showModalTxDetails(data.item);">{{ formatTimestamp(data.item.timestamp) }}</b-link>
                  <!-- <b-link :href="'https://sepolia.etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'txIndex: ' + data.item.transactionIndex + ' logIndex: ' + data.item.logIndex" target="_blank">
                    {{ formatTimestamp(data.item.timestamp) }}
                  </b-link> -->
                  <!-- <font size="-2">
                    {{ '.' + data.item.transactionIndex + '/' + data.item.logIndex }}
                  </font> -->
                </template>
                <template #cell(action)="data">
                  {{ actionText[data.item.action] || "Unknown" }}
                </template>
                <template #cell(taker)="data">
                  <b-link v-if="data.item.taker" :href="'https://sepolia.etherscan.io/address/' + data.item.taker" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                    {{ data.item.taker == coinbase ? "(me)" : data.item.taker.substring(0, 10) }}
                  </b-link>
                </template>
                <template #cell(maker)="data">
                  <b-link v-if="data.item.maker" :href="'https://sepolia.etherscan.io/address/' + data.item.maker" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                    {{ data.item.maker == coinbase ? "(me)" : data.item.maker.substring(0, 10) }}
                  </b-link>
                </template>
                <template #cell(base)="data">
                  <b-link v-if="data.item.base" :href="'https://sepolia.etherscan.io/token/' + data.item.base" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                    {{ settings.tokens[data.item.base] && settings.tokens[data.item.base].symbol }}
                  </b-link>
                </template>
                <template #cell(quote)="data">
                  <b-link v-if="data.item.quote" :href="'https://sepolia.etherscan.io/token/' + data.item.quote" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                    {{ settings.tokens[data.item.quote] && settings.tokens[data.item.quote].symbol }}
                  </b-link>
                </template>
                <template #cell(price)="data">
                  {{ formatERC20(data.item.price, 12) }}
                </template>
                <template #cell(tokens)="data">
                  <div v-if="data.item.tokens">
                    {{ (data.item.buySell == 0 ? '' : '-') + formatERC20(data.item.tokens, data.item.baseDecimals) }}
                  </div>
                </template>
                <template #cell(quoteTokens)="data">
                  <div v-if="data.item.quoteTokens">
                    {{ (data.item.buySell != 0 ? '' : '-') + formatERC20(data.item.quoteTokens, data.item.quoteDecimals) }}
                  </div>
                </template>
              </b-table>
            </b-card-text>
          </b-card>

          <!-- 3:TOKENS -->
          <b-card v-if="coinbase && settings.tabIndex == 3000" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              ERC-20 Tokens
            </template>
            <div class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.tokensTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Account address/name filter'" placeholder="ðŸ” add/name regex" style="min-width: 8.0rem;"></b-form-input>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div v-if="!sync.section" class="mt-0 pr-1">
                <b-button size="sm" @click="syncTokens()" variant="primary" v-b-popover.hover.top="'Sync token allowance to Chadex, balances and total supplies'">Sync</b-button>
              </div>
              <div class="mt-1" style="width: 250px;">
                <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'Click the button on the right to stop. This process can be continued later'">
                  <b-progress-bar :value="sync.completed">
                    {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                  </b-progress-bar>
                </b-progress>
              </div>
              <div class="ml-0 mt-1">
                <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <!--
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.tokensTable.sortOption" @change="saveSettings" :options="accountsSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              -->
              <div class="mt-0 pl-1">
                <font size="-2" v-b-popover.hover.top="'# tokens'">{{ filteredSortedTokens.length + '/' + Object.keys(settings.tokens).length }}</font>
              </div>
              <div class="mt-0 pl-1">
                <b-pagination size="sm" v-model="settings.tokensTable.currentPage" @input="saveSettings" :total-rows="filteredSortedAccounts.length" :per-page="settings.tokensTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.tokensTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Yeah. Page size'"></b-form-select>
              </div>
            </div>

            <b-modal id="allowance-modal-prevent-closing" ref="modal" title="Change Allowance To Chadex" @show="allowanceFormResetModal" @hidden="allowanceFormResetModal" @ok="allowanceFormHandleOk">
              <form ref="allowanceForm" @submit.stop.prevent="allowanceFormHandleSubmit">
                <b-form-group label="Amount" label-for="allowance-amount" :state="allowanceAmountState" invalid-feedback="Please enter a valid amount">
                  <b-form-input id="allowance-amount" v-model="allowanceFormData.amount" :state="allowanceAmountState" required placeholder="0.12345"></b-form-input>
                </b-form-group>
              </form>
            </b-modal>

            <b-modal id="weth-modal-prevent-closing" ref="modal" title="ETH To WETH Convertor" @show="wethFormResetModal" @hidden="wethFormResetModal" @ok="wethFormHandleOk">
              <form ref="wethForm" @submit.stop.prevent="wethFormHandleSubmit">
                <b-form-group label="">
                  <b-form-radio v-model="wethFormData.direction" value="ew">Wrap ETH</b-form-radio>
                  <b-form-radio v-model="wethFormData.direction" value="we">Unwrap WETH</b-form-radio>
                </b-form-group>
                <b-form-group label="Amount" label-for="weth-amount" :state="wethAmountState" invalid-feedback="Please enter a valid amount">
                  <b-form-input id="weth-amount" v-model="wethFormData.amount" :state="wethAmountState" required placeholder="0.12345"></b-form-input>
                </b-form-group>
              </form>
            </b-modal>

            <b-table small fixed striped responsive hover :fields="tokensFields" :items="pagedFilteredSortedTokens" show-empty empty-html="Click [+] above to add a new ERC-20 token contract. Currently only TURBO supported" head-variant="light" class="mx-0 my-1">
              <template #head(address)="data">
                Address <b-link v-b-modal.new-coin-modal-prevent-closing variant="link" v-b-popover.hover.top="'Add new token'"><b-icon-plus-square shift-v="+1" font-scale="0.8"></b-icon-plus-square></b-link>
                <b-modal id="new-coin-modal-prevent-closing" ref="modal" title="New ERC-20 Token Address" @show="newCoinAddressResetModal" @hidden="newCoinAddressResetModal" @ok="newCoinAddressHandleOk">
                  <form ref="coinForm" @submit.stop.prevent="newCoinAddressHandleSubmit">
                    <b-form-group label="Address" label-for="name-input" :state="newCoinAddressState" description="Pre-filled with WEENUS on Sepolia for initial testing" invalid-feedback="Please enter a valid Ethereum ERC-20 address">
                      <b-form-input id="name-input" v-model="newCoinAddress" :state="newCoinAddressState" required placeholder="0x1234..."></b-form-input>
                    </b-form-group>
                  </form>
                </b-modal>
              </template>
              <template #head(sync)="data">
                Sync
                <!--
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleSyncAccounts(pagedFilteredSortedAccounts)">Toggle sync for all accounts on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleSyncAccounts(filteredSortedAccounts)">Toggle sync for all accounts on all pages</b-dropdown-item>
                </b-dropdown>
                -->
              </template>
              <template #head(include)="data">
                Include
                <!--
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleIncludeAccounts(pagedFilteredSortedAccounts)">Toggle include for all accounts on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleIncludeAccounts(filteredSortedAccounts)">Toggle include for all accounts on all pages</b-dropdown-item>
                </b-dropdown>
                -->
              </template>
              <template #cell(address)="data">
                <b-link :href="'https://sepolia.etherscan.io/address/' + data.item.address + '#code'" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                  {{ data.item.address.substring(0, 10) }}
                </b-link>
              </template>
              <template #cell(allowance)="data">
                <b-link v-b-modal.allowance-modal-prevent-closing @click="allowanceFormData.token = data.item.address; allowanceFormData.decimals = data.item.decimals;" variant="link" v-b-popover.hover.top="'Change allowance. Click Sync after tx included'">{{ formatERC20(data.item.allowance, data.item.decimals) }}</b-link>
              </template>
              <template #cell(balance)="data">
                {{ formatERC20(data.item.balance, data.item.decimals) }}
              </template>
              <template #cell(totalSupply)="data">
                {{ formatERC20(data.item.totalSupply, data.item.decimals) }}
              </template>
              <template #cell(sync)="data">
                <b-form-checkbox size="sm" :checked="data.item.sync ? 1 : 0" value="1" @change="toggleAccountField(data.item.address, 'sync')" v-b-popover.hover="'Include in sync process?'"></b-form-checkbox>
              </template>
              <template #cell(include)="data">
                <b-form-checkbox size="sm" :checked="data.item.include ? 1 : 0" value="1" @change="toggleAccountField(data.item.address, 'include')" v-b-popover.hover="'Include in NFTs view?'"></b-form-checkbox>
              </template>
              <template #cell(getSome)="data">
                <div v-if="tokenInfo[data.item.address] && tokenInfo[data.item.address].faucet == 'weenus'">
                  <b-link @click="mintWeenus(data.item.address);" v-b-popover.hover.top="'Faucet drips 1,000 tokens each 0 value tx. Click Sync after tx included'">Drip</b-link>
                </div>
                <div v-else-if="tokenInfo[data.item.address] && tokenInfo[data.item.address].faucet == 'weth'">
                  <b-link v-b-modal.weth-modal-prevent-closing variant="link" v-b-popover.hover.top="'Wrap/Unwrap ETH. Click Sync after tx included'">Convert</b-link>
                </div>
                <div v-else>
                  On Exchange
                </div>
                <!-- <b-form-checkbox size="sm" :checked="data.item.include ? 1 : 0" value="1" @change="toggleAccountField(data.item.address, 'include')" v-b-popover.hover="'Include in NFTs view?'"></b-form-checkbox> -->
              </template>
              <template #cell(delete)="data">
                <b-link size="sm" @click="deleteToken(data.item.address)" variant="link" v-b-popover.hover="'Delete token'"><b-icon-trash style="color: #ff0000;" shift-v="+1" font-scale="1.0"></b-icon-trash></b-link>
              </template>
            </b-table>

          </b-card>

          <!-- 4:RAW -->
          <b-card v-if="coinbase && settings.tabIndex == 4000" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Raw Interface
            </template>
            <b-card-text class="m-0 p-0">
              <b-card no-body no-header bg-variant="light" class="m-1 p-1 w-75">
                <b-card-body class="m-1 p-1">
                  <b-form-group label-cols-lg="2" label="Chadex Execute" label-size="md" label-class="font-weight-bold pt-0" class="mb-0">
                    <b-form-group label="Action:" label-for="raw-action" label-size="sm" label-cols-sm="2" label-align-sm="right" description="'0' fill, '1' fill or kill, '2' fill & add order, '3' remove order, '4' update expiry and tokens" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="raw-action" v-model.trim="raw.action" placeholder="'0' to '4'" class="w-25"></b-form-input>
                    </b-form-group>
                    <b-form-group label="Base Token:" label-for="raw-basetoken" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Defaults to WEENUS" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="raw-basetoken" v-model.trim="raw.base" placeholder="0x1234..." class="w-75"></b-form-input>
                    </b-form-group>
                    <b-form-group label="Quote Token:" label-for="raw-quotetoken" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Defaults to WETH" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="raw-quotetoken" v-model.trim="raw.quote" placeholder="0x1234..." class="w-75"></b-form-input>
                    </b-form-group>
                    <b-form-group label="Buy or Sell:" label-for="raw-buysell" label-size="sm" label-cols-sm="2" label-align-sm="right" description="'0' buy, '1' sell" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="raw-buysell" v-model.trim="raw.buySell" placeholder="'0' or '1'" class="w-25"></b-form-input>
                    </b-form-group>
                    <b-form-group label="Price:" label-for="raw-price" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Up to 12 whole-number and 11 decimal places" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="raw-price" v-model.trim="raw.price" placeholder="e.g. 0.69012345678" class="w-50"></b-form-input>
                    </b-form-group>
                    <b-form-group label="Target Price:" label-for="raw-targetprice" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Target price ONLY when filling orders (max for Buy, min for Sell, 0 to ignore)" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="raw-targetprice" v-model.trim="raw.targetPrice" placeholder="e.g. 0.69015" class="w-50"></b-form-input>
                    </b-form-group>
                    <b-form-group label="Expiry:" label-for="raw-expiry" label-size="sm" label-cols-sm="2" label-align-sm="right"  description="Unix time. '0' for no expiry" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="raw-expiry" v-model.trim="raw.expiry" placeholder="e.g. '1704027599' for 23:59:59 31/12/2023" class="w-25"></b-form-input>
                    </b-form-group>
                    <b-form-group label="Tokens:" label-for="raw-tokens" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Tokens. e.g. '1.012345678901234567'" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="raw-tokens" v-model.trim="raw.tokens" placeholder="1.01234567891234567" class="w-50"></b-form-input>
                    </b-form-group>
                    <b-form-group label="" label-for="raw-submit" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-button size="sm" :disabled="false" id="raw-submit" @click="executeRaw()" variant="warning">Execute</b-button>
                    </b-form-group>

                    <!-- <b-form-group label="To:" label-for="message-to" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="message-to" v-model.trim="message.to" placeholder="0x1234... (optional)" class="w-50"></b-form-input>
                    </b-form-group>
                    <b-form-group label="Topic:" label-for="message-topic" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="message-topic" v-model.trim="message.topic" placeholder="{topic}" class="w-50"></b-form-input>
                    </b-form-group>
                    <b-form-group label="Text:" label-for="message-text" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-form-input type="text" size="sm" id="message-text" v-model.trim="message.text" placeholder="{text}" class="w-75"></b-form-input>
                    </b-form-group>
                    <b-form-group label="" label-for="message-submit" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-button size="sm" :disabled="message.topic == null && message.text == null" id="message-submit" @click="sendMessage()" variant="warning">Send Message</b-button>
                    </b-form-group> -->
                  </b-form-group>
                </b-card-body>
              </b-card>
            </b-card-text>
          </b-card>

          <!-- 5:INFO -->
          <b-card v-if="coinbase && settings.tabIndex == 5000" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Info
            </template>
            <b-card-text class="m-0 p-0">
              <b-card no-body no-header bg-variant="light" class="m-1 p-1 w-75">
                <b-card-body class="m-1 p-1">
                  <b-form-group label-cols-lg="2" label="Chadex Info" label-size="md" label-class="font-weight-bold pt-0" class="mb-0">
                    <b-form-group label="Address:" label-for="info-chadexaddress" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-link id="info-chadexaddress" :href="'https://sepolia.etherscan.io/address/' + chadexAddress + '#code'" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                        {{ chadexAddress }}
                      </b-link>
                    </b-form-group>
                  </b-form-group>
                  <b-form-group label-cols-lg="2" label="Sepolia Faucets" label-size="md" label-class="font-weight-bold pt-0" class="mb-0 mt-2">
                    <b-form-group label="List:" label-for="info-faucets" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                      <b-link id="info-faucets" :href="'https://faucetlink.to/sepolia'" v-b-popover.hover.bottom="'Get Sepolia ETH'" target="_blank">
                        https://faucetlink.to/sepolia
                      </b-link>
                    </b-form-group>
                  </b-form-group>
                </b-card-body>
              </b-card>
            </b-card-text>
          </b-card>

          <b-card v-if="coinbase && settings.tabIndex == 10000" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <div class="d-flex flex-wrap m-0 p-0">
              <div v-if="false" class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.tokensTable.tokenFilter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Token id and name filter'" placeholder="ðŸ” token id/name regex" style="min-width: 8.0rem;"></b-form-input>
              </div>
              <div v-if="false" class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.tokensTable.collectionfilter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Collection name filter'" placeholder="ðŸ” collection name" style="min-width: 8.0rem;"></b-form-input>
              </div>
              <div v-if="false" class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="settings.showAdditionalFilters" @click="saveSettings" variant="link" v-b-popover.hover.top="'Additional filters'"><span v-if="settings.showAdditionalFilters"><b-icon-funnel-fill shift-v="+1" font-scale="1.0"></b-icon-funnel-fill></span><span v-else><b-icon-funnel shift-v="+1" font-scale="1.0"></b-icon-funnel></span></b-button>
              </div>
              <div v-if="Object.keys(settings.filters).length > 0" class="mt-0 pr-1">
                <b-button size="sm" @click="resetAdditionalFilters();" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Reset additional filters'">
                  <b-iconstack shift-v="-1" font-scale="1">
                    <b-icon stacked icon="funnel-fill" variant="info" scale="1"></b-icon>
                    <b-icon stacked icon="x" variant="danger" scale="1.3"></b-icon>
                  </b-iconstack>
                </b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div v-if="!sync.section" class="mt-0 pr-1">
                <b-button size="sm" @click="syncAll(0)" variant="primary" v-b-popover.hover.top="'Select NFT collections to for accounts'">Sync</b-button>
              </div>
              <div class="mt-1" style="width: 250px;">
                <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'Click the button on the right to stop. This process can be continued later'">
                  <b-progress-bar :value="sync.completed">
                    {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                  </b-progress-bar>
                </b-progress>
              </div>
              <div class="ml-0 mt-1">
                <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.transfersTable.sortOption" @change="saveSettings" :options="transfersSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pl-1">
                <font size="-2" v-b-popover.hover.top="'# tokens'">{{ filteredSortedTransfers.length + '/' + tokens.length }}</font>
              </div>
              <div class="mt-0 pl-1">
                <b-pagination size="sm" v-model="settings.transfersTable.currentPage" @input="saveSettings" :total-rows="filteredSortedTransfers.length" :per-page="settings.transfersTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.transfersTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Yeah. Page size'"></b-form-select>
              </div>
            </div>

            <!-- ADDITIONAL FILTERS -->
            <div v-if="settings.showAdditionalFilters" class="d-flex flex-wrap m-0 p-0">
              <div class="mt-0 pr-1" style="width: 13.0rem;">
                <b-card no-header no-body class="m-0 mt-1 p-0 border-1">
                  <b-card-body class="m-0 p-0">
                    <font size="-2">
                      <b-table small fixed striped sticky-header="200px" :fields="groupsFilterFields" :items="getAllGroups" head-variant="light">
                        <template #cell(select)="data">
                          <b-form-checkbox size="sm" :checked="(settings.filters['groups'] && settings.filters['groups'][data.item.group]) ? 1 : 0" value="1" @change="filterChanged('groups', data.item.group)"></b-form-checkbox>
                        </template>
                        <template #cell(group)="data">
                          {{ data.item.group }}
                        </template>
                      </b-table>
                    </font>
                  </b-card-body>
                </b-card>
              </div>

              <div class="mt-0 pr-1" style="width: 13.0rem;">
                <b-card no-header no-body class="m-0 mt-1 p-0 border-1">
                  <b-card-body class="m-0 p-0">
                    <font size="-2">
                      <b-table small fixed striped sticky-header="200px" :fields="accountsFilterFields" :items="getAllAccounts" head-variant="light">
                        <template #cell(select)="data">
                          <b-form-checkbox size="sm" :checked="(settings.filters['accounts'] && settings.filters['accounts'][data.item.account]) ? 1 : 0" value="1" @change="filterChanged('accounts', data.item.account)"></b-form-checkbox>
                        </template>
                        <template #cell(account)="data">
                          {{ data.item.accountName }}
                        </template>
                      </b-table>
                    </font>
                  </b-card-body>
                </b-card>
              </div>

              <div class="mt-0 pr-1" style="width: 13.0rem;">
                <b-card no-header no-body class="m-0 mt-1 p-0 border-1">
                  <b-card-body class="m-0 p-0">
                    <font size="-2">
                      <b-table small fixed striped sticky-header="200px" :fields="collectionsFilterFields" :items="getAllPools" head-variant="light">
                        <template #cell(select)="data">
                          <b-form-checkbox size="sm" :checked="(settings.filters['collections'] && settings.filters['collections'][data.item.collection]) ? 1 : 0" value="1" @change="filterChanged('collections', data.item.collection)"></b-form-checkbox>
                        </template>
                        <template #cell(account)="data">
                          {{ data.item.collectionName }}
                        </template>
                      </b-table>
                    </font>
                  </b-card-body>
                </b-card>
              </div>

            </div>

            <!-- <b-table small fixed striped responsive hover selectable select-mode="single" @row-selected="showModalTxDetails" :fields="transfersFields" :items="pagedFilteredSortedTransfers" show-empty empty-html="Add your tokens in the [tokens] menu, then click [Sync] above" head-variant="light" class="mx-0 my-1"> -->
            <b-table small fixed striped responsive hover :fields="transfersFields" :items="pagedFilteredSortedTransfers" show-empty empty-html="Please click [Sync] above" head-variant="light" class="mx-0 my-1">
              <template #cell(number)="data">
                <!--
                <b-form-checkbox size="sm" :checked="selectedCollections[data.item.contract] ? 1 : 0" value="1" @change="toggleSelectedCollections([data.item])">
                  {{ parseInt(data.index) + ((settings.collections.currentPage - 1) * settings.collections.pageSize) + 1 }}
                </b-form-checkbox>
                -->
                {{ parseInt(data.index) + ((settings.transfersTable.currentPage - 1) * settings.transfersTable.pageSize) + 1 }}
              </template>
              <template #cell(timestamp)="data">
                <font size="-1">
                  <b-link :href="'https://etherscan.io/tx/' + data.item[0]" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                    {{ formatTimestamp(data.item[2]) }}
                  </b-link>
                  <font size="-2">
                    <b-link @click="showModalTxDetails(data.item);">ðŸ”</b-link>
                  </font>
                </font>
                <br />
                <font size="-2">
                  {{ data.item[1] + ':' + data.item[3] + ':' + data.item[0] }}
                </font>
              </template>
              <template #cell(info)="data">
                <div v-if="data.item[4]">
                  <div v-for="action of data.item[4]">
                    <font size="-1"><pre>{{ transactionTypes[action[1]] || '(Unknown)' }}</pre></font>
                    <br />
                  </div>
                </div>
                <!--
                <div v-if="data.item.info">
                  <div v-if="data.item.info.type == 'tx'">
                    Transfer
                  </div>
                  <div v-else-if="data.item.info.type == 'addLiquidity'">
                    Add Liquidity
                  </div>
                  <div v-else-if="data.item.info.type == 'dex'">
                    DEX: <font size="-2"><pre>{{ data.item }}</pre></font>
                  </div>
                  <div v-else>
                    Unknown
                  </div>
                </div>
                <div v-else>
                  <font size="-2"><pre>{{ data.item }}</pre></font>
                </div>
                -->
                <font size="-2"><pre>{{ data.item }}</pre></font>
              </template>
              <template #cell(from)="data">
                <div v-if="data.item[4]">
                  <div v-for="action of data.item[4]">
                    <font size="-1">
                      <b-link v-if="action" :href="'https://etherscan.io/address/' + indexToAddress[action[2]]" v-b-popover.hover.bottom="'View account in etherscan.io'" target="_blank">
                        {{ ensOrAddress(indexToAddress[action[2]]) }}
                      </b-link>
                    </font>
                    <br />
                  </div>
                </div>
                <!--
                <font size="-2">
                  <b-link v-if="data.item.info" :href="'https://etherscan.io/address/' + data.item.info.from" v-b-popover.hover.bottom="'View account in etherscan.io'" target="_blank">
                    {{ ensOrAddress(data.item.info.from) }}
                  </b-link>
                </font>
                -->
              </template>
              <template #cell(to)="data">
                <div v-if="data.item[4]">
                  <div v-for="action of data.item[4]">
                    <font size="-1">
                      <b-link v-if="action" :href="'https://etherscan.io/address/' + indexToAddress[action[3]]" v-b-popover.hover.bottom="'View account in etherscan.io'" target="_blank">
                        {{ ensOrAddress(indexToAddress[action[3]]) }}
                      </b-link>
                    </font>
                    <br />
                  </div>
                </div>
                <!--
                <font size="-2">
                  <b-link v-if="data.item.info" :href="'https://etherscan.io/address/' + data.item.info.to" v-b-popover.hover.bottom="'View account in etherscan.io'" target="_blank">
                    {{ ensOrAddress(data.item.info.to) }}
                  </b-link>
                </font>
                -->
              </template>
              <template #cell(tokens)="data">
                <div v-if="data.item[4]">
                  <div v-for="action of data.item[4]">
                    <font size="-1">
                      {{ formatERC20(action[4], indexToDecimals[action[5]]) }}
                    </font>
                    <div v-if="action.length > 6">
                      <font size="-1">
                        {{ formatERC20(action[6], indexToDecimals[action[7]]) }}
                      </font>
                    </div>
                  </div>
                </div>
              </template>
              <template #cell(token)="data">
                <div v-if="data.item[4]">
                  <div v-for="action of data.item[4]">
                    <font size="-1">
                      {{ indexToSymbols[action[5]] }}
                    </font>
                    <div v-if="action.length > 6">
                      <font size="-1">
                        {{ indexToSymbols[action[7]] || ("Unknown: " + action[7]) }}
                      </font>
                    </div>
                  </div>
                </div>
              </template>
              <template #cell(rate)="data">
                <div v-if="data.item.actions">
                  <div v-for="action of data.item.actions">
                    <div v-if="action.length > 8">
                      <font size="-1">
                        {{ formatRate(action[12], 18, 10) }}
                      </font>
                    </div>
                    <br />
                  </div>
                </div>
              </template>
              <template #cell(token1)="data">
                <div class="d-flex flex-row">
                  <div>
                    <b-avatar rounded variant="light" size="8.0rem" :src="data.item.image">
                    </b-avatar>
                  </div>
                  <div class="ml-2">
                    <b-link @click="showModalTxDetails(data.item);">{{ data.item.name }}</b-link>
                    <br />
                    {{ data.item.collectionName }}
                    <br />
                    {{ data.item.tokenId }}
                    <br />
                    {{ data.item.ownerName }}
                    <br />
                    <b-button size="sm" @click="requestReservoirAPITokenMetadataRefresh(data.item)" variant="link" v-b-popover.hover.top="'Request a metadata refresh on the Reservoir API. Re-sync after a few minutes'"><b-icon-arrow-clockwise shift-v="+1" font-scale="1.2"></b-icon-arrow-clockwise></b-button>
                    <!-- Volume: 1d {{ commify(data.item.volume["1day"]) + 'e' }}; 7d {{ commify(data.item.volume["7day"]) + 'e' }}; 30d {{ commify(data.item.volume["30day"]) + 'e' }}; allTime {{ commify(data.item.volume["allTime"]) + 'e' }}; tokens {{ data.item.tokenCount }}; onSale {{ data.item.onSaleCount }} -->
                  </div>
                </div>
              </template>
              <template #cell(lastSaleAmount)="data">
                <div v-if="data.item.lastSale">
                  {{ data.item.lastSale.amount }} {{ data.item.lastSale.currency }} <font size="-2">{{ data.item.lastSale.amountInUSD }} USD</font>
                </div>
              </template>
              <template #cell(lastSaleTime)="data">
                <div v-if="data.item.lastSale">
                  {{ formatTimestamp(data.item.lastSale.timestamp) }}
              </div>
              </template>
            </b-table>
          </b-card>

          <b-card v-if="coinbase && settings.tabIndex == 4000" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <div class="d-flex flex-wrap m-0 p-0">
              <!--
              <div class="mt-0 pr-1">
                <b-form-input type="text" size="sm" v-model.trim="settings.accountsTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Account address/name filter'" placeholder="ðŸ” add/name regex" style="min-width: 8.0rem;"></b-form-input>
              </div>
              -->
              <div class="mt-0 flex-grow-1">
              </div>
              <!--
              <div v-if="!sync.section" class="mt-0 pr-1">
                <b-button size="sm" :pressed.sync="settings.editAccounts" @click="saveSettings" :variant="settings.editAccounts ? 'danger' : 'link'" v-b-popover.hover.top="settings.editAccounts ? 'End adding/editing accounts. Click Sync to apply changes' : 'Add/Edit accounts'"><b-icon-pencil shift-v="+1" font-scale="1.0"></b-icon-pencil></b-button>
              </div>
              <div class="mt-0 flex-grow-1">
              </div>
              -->
              <!--
              <div class="mt-0 pr-1">
                <b-dropdown size="sm" variant="link" v-b-popover.hover.top="'Export/Import accounts'">
                  <template #button-content>
                    <b-icon-file-earmark-spreadsheet shift-v="+1" font-scale="1.2"></b-icon-file-earmark-spreadsheet>
                  </template>
                  <b-dropdown-item @click="exportAccounts" >Export</b-dropdown-item>
                  <b-dropdown-item @click="showModalAccountsImport();">Import</b-dropdown-item>
                </b-dropdown>
              </div>
              -->
              <div class="mt-0 flex-grow-1">
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.accountsTable.sortOption" @change="saveSettings" :options="accountsSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
              </div>
              <div class="mt-0 pl-1">
                <font size="-2" v-b-popover.hover.top="'# tokens'">{{ filteredSortedAccounts.length + '/' + Object.keys(settings.accounts).length }}</font>
              </div>
              <div class="mt-0 pl-1">
                <b-pagination size="sm" v-model="settings.accountsTable.currentPage" @input="saveSettings" :total-rows="filteredSortedAccounts.length" :per-page="settings.accountsTable.pageSize" style="height: 0;"></b-pagination>
              </div>
              <div class="mt-0 pl-1">
                <b-form-select size="sm" v-model="settings.accountsTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Accounts page size'"></b-form-select>
              </div>
            </div>

            <b-table small fixed striped responsive hover :fields="accountsFields" :items="pagedFilteredSortedAccounts" show-empty empty-html="Click [+] above to add your account" head-variant="light" class="mx-0 my-1">
              <template #head(address)="data">
                Account <b-button v-b-modal.new-account-modal-prevent-closing variant="link" v-b-popover.hover.top="'Add new account'"><b-icon-plus-square shift-v="+1" font-scale="0.8"></b-icon-plus-square></b-button>
                <b-modal id="new-account-modal-prevent-closing" ref="modal" title="New Account" @show="newAccountResetModal" @hidden="newAccountResetModal" @ok="newAccountHandleOk">
                  <form ref="accountForm" @submit.stop.prevent="newAccountHandleSubmit">
                    <b-form-group label="Address" label-for="name-input" :state="newAddressState" invalid-feedback="Please enter a valid Ethereum address">
                      <b-form-input id="name-input" v-model="newAddress" :state="newAddressState" required placeholder="0x1234..."></b-form-input>
                    </b-form-group>
                  </form>
                </b-modal>
              </template>
              <!--
              <template #head(sync)="data">
                Sync
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleSyncAccounts(pagedFilteredSortedAccounts)">Toggle sync for all accounts on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleSyncAccounts(filteredSortedAccounts)">Toggle sync for all accounts on all pages</b-dropdown-item>
                </b-dropdown>
              </template>
              -->
              <!--
              <template #head(include)="data">
                Include
                <b-dropdown size="sm" variant="link" v-b-popover.hover="'Toggle selection'">
                  <template #button-content>
                    <b-icon-check-square shift-v="+1" font-scale="0.9"></b-icon-check-square>
                  </template>
                  <b-dropdown-item href="#" @click="toggleIncludeAccounts(pagedFilteredSortedAccounts)">Toggle include for all accounts on this page</b-dropdown-item>
                  <b-dropdown-item href="#" @click="toggleIncludeAccounts(filteredSortedAccounts)">Toggle include for all accounts on all pages</b-dropdown-item>
                </b-dropdown>
              </template>
              -->
              <template #cell(group)="data">
                <b-form-input type="text" size="sm" v-model.trim="data.item.group" @change="setAccountField(data.item.address, 'group', $event)" placeholder="group"></b-form-input>
              </template>
              <template #cell(name)="data">
                <b-form-input type="text" size="sm" v-model.trim="data.item.name" @change="setAccountField(data.item.address, 'name', $event)" placeholder="name"></b-form-input>
              </template>
              <!--
              <template #cell(sync)="data">
                <b-form-checkbox size="sm" :checked="data.item.sync ? 1 : 0" value="1" @change="toggleAccountField(data.item.address, 'sync')" v-b-popover.hover="'Include in sync process?'"></b-form-checkbox>
              </template>
              <template #cell(include)="data">
                <b-form-checkbox size="sm" :checked="data.item.include ? 1 : 0" value="1" @change="toggleAccountField(data.item.address, 'include')" v-b-popover.hover="'Include in NFTs view?'"></b-form-checkbox>
              </template>
              -->
              <template #cell(delete)="data">
                <b-button size="sm" @click="deleteAccount(data.item.address)" variant="link" v-b-popover.hover="'Delete account'"><b-icon-trash style="color: #ff0000;" shift-v="+1" font-scale="1.0"></b-icon-trash></b-button>
              </template>
            </b-table>
          </b-card>
        </b-card>
        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div v-if="false" class="mt-0 pr-1">
              <b-form-input type="text" size="sm" v-model.trim="settings.tokensTable.tokenFilter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Token id and name filter'" placeholder="ðŸ” token id/name regex" style="min-width: 8.0rem;"></b-form-input>
            </div>
            <div v-if="false" class="mt-0 pr-1">
              <b-form-input type="text" size="sm" v-model.trim="settings.tokensTable.collectionfilter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Collection name filter'" placeholder="ðŸ” collection name" style="min-width: 8.0rem;"></b-form-input>
            </div>
            <div v-if="false" class="mt-0 pr-1">
              <b-button size="sm" :pressed.sync="settings.showAdditionalFilters" @click="saveSettings" variant="link" v-b-popover.hover.top="'Additional filters'"><span v-if="settings.showAdditionalFilters"><b-icon-funnel-fill shift-v="+1" font-scale="1.0"></b-icon-funnel-fill></span><span v-else><b-icon-funnel shift-v="+1" font-scale="1.0"></b-icon-funnel></span></b-button>
            </div>
            <div class="ml-0 mt-1 pl-1">
              <font v-if="connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chainId == '1' ? 'Mainnet' : 'Unsupported' }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>CryptoPunksData</i> &copy; Bok Consulting Pty Ltd 2023
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,

          settings: {
            tabIndex: 0,
            showFilter: false,
            showAdditionalFilters: false,
            filters: {},
            punksTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'punkidasc',
            },
            activityTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'txorderdsc',
            },
            // pairsTable: {
            //   filter: null,
            //   currentPage: 1,
            //   pageSize: 10,
            //   sortOption: 'symbolquotebaseasc',
            // },
            // pairTable: {
            //   selectedPair: null,
            //   buyOrders: {
            //     filter: null,
            //     currentPage: 1,
            //     pageSize: 10,
            //     // sortOption: 'symbolquotebaseasc',
            //   },
            //   sellOrders: {
            //     filter: null,
            //     currentPage: 1,
            //     pageSize: 10,
            //     // sortOption: 'symbolquotebaseasc',
            //   },
            //   history: {
            //     filter: null,
            //     currentPage: 1,
            //     pageSize: 20,
            //     sortOption: 'timestampdsc',
            //   },
            // },
            // tokensTable: {
            //   filter: null,
            //   currentPage: 1,
            //   pageSize: 10,
            //   sortOption: 'lastsaledsc',
            // },
            editAccounts: false,
            accounts: {},
            accountsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'groupnameasc',
            },
            transfersTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'blocknumberdsc',
            },
            tokensTable: {
              tokenFilter: null,
              collectionFilter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'lastsaledsc',
            },
            version: 5,
          },

          contracts: [
            { name: "CryptoPunks V1", address: CRYPTOPUNKSV1ADDRESS, abi: CRYPTOPUNKSV1ABI, deploymentBlockNumber: CRYPTOPUNKSV1DEPLOYMENTBLOCKNUMBER },
            { name: "CryptoPunks V2", address: CRYPTOPUNKSV2ADDRESS, abi: CRYPTOPUNKSV2ABI, deploymentBlockNumber: CRYPTOPUNKSV2DEPLOYMENTBLOCKNUMBER },
            { name: "WrappedCryptoPunks V1", address: WRAPPEDCRYPTOPUNKSV1ADDRESS, abi: WRAPPEDCRYPTOPUNKSV1ABI, deploymentBlockNumber: WRAPPEDCRYPTOPUNKSV1DEPLOYMENTBLOCKNUMBER },
            { name: "WrappedCryptoPunks V2", address: WRAPPEDCRYPTOPUNKSV2ADDRESS, abi: WRAPPEDCRYPTOPUNKSV2ABI, deploymentBlockNumber: WRAPPEDCRYPTOPUNKSV2DEPLOYMENTBLOCKNUMBER },
          ],

          txs: {},

          newCoinAddress: null,
          newAddress: null,
          // allowanceFormData: {
          //   amount: null,
          //   token: null,
          //   decimals: null,
          // },
          // wethFormData: {
          //   direction: "ew",
          //   amount: null,
          // },
          // sell: {
          //   action: 2,
          //   price: null,
          //   targetPrice: null,
          //   expiry: 1704027599,
          //   tokens: null,
          //   quoteTokens: null,
          // },
          // buy: {
          //   action: 2,
          //   price: null,
          //   targetPrice: null,
          //   expiry: 1704027599,
          //   tokens: null,
          //   quoteTokens: null,
          // },
          // raw: {
          //   action: 2,
          //   base: "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9",
          //   quote: "0x07391dbE03e7a0DEa0fce6699500da081537B6c3",
          //   buySell: 0,
          //   price: "0.69012345678",
          //   targetPrice: "0.69015",
          //   expiry: 1704027599,
          //   tokens: "1.012345678901234567",
          // },

          restoreFile: null,
          restoreAddresses: null,
          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },
          modalTxDetails: {
            item: null,
            tx: null,
            tradeInputs: null,
            data: null,
            token: null,
            collection: null,
          },
          // modalTokenDetails: {
          //   tokenIndex: null,
          //   symbol: null,
          //   name: null,
          //   decimals: null,
          //   balance: null,
          //   allowance: null,
          //   totalSupply: null,
          // },
          // modalMakerOrder: {
          //   pairKey: null,
          //   buySell: null,
          //   price: null,
          //   orderKey: null,
          //   makerIndex: null,
          //   expiry: null,
          //   originalTokens: null,
          //   tokens: null,
          //   availableBase: null,
          //   availableQuote: null,
          // },

          addressToIndex: {},
          indexToAddress: [],

          pairToIndex: {},
          indexToPair: [],

          indexToName: {},
          indexToSymbols: {},
          indexToDecimals: {},

          pairs: {},
          pair: {},
          tokens: {},
          events: {}, // TODO: Only load relevant events to reduce memory load, in loadCurrentData()

          selectedBuyOrders: {},
          selectedSellOrders: {},

          transfers: {},
          pools: {},
          trades: {},
          blockTimestamps: {},
          collections: {},
          selectedCollections: {},
          selectedMainTable: {},

          // messages: {
          //   invalidInputTokens: "Please enter a valid amount - up to 18 whole numbers and 24 decimal places",
          //   invalidInputPrice: "Please enter a valid price - up to 12 whole numbers and 12 decimal places",
          // },

          // tokenInfo: {
          //   "0x03563574B3839e2CdD6281D8741497Ba82FD6739": {
          //       "faucet": null,
          //       "symbol": "BOKKY",
          //   },
          //   "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9": {
          //       "faucet": "weenus",
          //       "symbol": "WEENUS",
          //   },
          //   "0x07391dbE03e7a0DEa0fce6699500da081537B6c3": {
          //       "faucet": "weth",
          //       "symbol": "WETH",
          //   },
          //   "0xc21d97673B9E0B3AA53a06439F71fDc1facE393B": {
          //     "faucet": "weenus",
          //       "symbol": "XEENUS",
          //   },
          //   "0x93fCA4c6E2525C09c95269055B46f16b1459BF9d": {
          //       "faucet": "weenus",
          //       "symbol": "YEENUS",
          //   },
          //   "0xe9EF74A6568E9f0e42a587C9363C9BcC582dcC6c": {
          //       "faucet": "weenus",
          //       "symbol": "ZEENUS",
          //   }
          // },

          actionText: {
            "pairadded": "Pair Added",
            "orderadded": "Order Added",
            "trade": "Trade",
            "tradesummary": "Trade Summary",
          },

          actionOptions: [
            { value: 0, text: 'Fill' },
            { value: 1, text: 'Fill Or Kill' },
            { value: 2, text: 'Fill And Add Order' },
            // { value: 3, text: 'Remove Order' },
            // { value: 4, text: 'Update Expiry And Tokens' },
          ],

          punksSortOptions: [
            { value: 'punkidasc', text: 'â–² PunkId' },
            { value: 'punkiddsc', text: 'â–¼ PunkId' },
          ],
          activitySortOptions: [
            { value: 'txorderasc', text: 'â–² TxOrder' },
            { value: 'txorderdsc', text: 'â–¼ TxOrder' },
          ],
          pairsSortOptions: [
            { value: 'symbolquotebaseasc', text: 'â–² Quote, â–² Base' },
            { value: 'symbolbasequoteasc', text: 'â–² Base, â–² Quote' },
          ],
          accountsSortOptions: [
            { value: 'groupnameasc', text: 'â–² Group, â–² Name' },
            { value: 'groupnamedsc', text: 'â–¼ Group, â–² Name' },
            { value: 'nameasc', text: 'â–² Name' },
            { value: 'namedsc', text: 'â–¼ Name' },
          ],
          transfersSortOptions: [
            { value: 'blocknumberasc', text: 'â–² Block Number' },
            { value: 'blocknumberdsc', text: 'â–¼ Block Number' },
          ],
          tokensSortOptions: [
            { value: 'lastsaleasc', text: 'â–² Last Sale' },
            { value: 'lastsaledsc', text: 'â–¼ Last Sale' },
          ],
          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],
          punksFields: [
            { key: 'punkId', label: 'PunkId', sortable: false, thStyle: 'width: 15%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'image', label: 'Image', sortable: false, thStyle: 'width: 45%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'attribute', label: 'Attributes', sortable: false, thStyle: 'width: 50%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          activityFields: [
            { key: 'punkId', label: 'PunkId', sortable: false, thStyle: 'width: 15%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'image', label: 'Image', sortable: false, thStyle: 'width: 45%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'attribute', label: 'Attributes', sortable: false, thStyle: 'width: 50%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          punkAttributesFields: [
            { key: 'select', label: '', thStyle: 'width: 10%;' },
            { key: 'attributeOption', label: 'Attribute' /*, sortable: true*/ },
            { key: 'attributeTotal', label: 'Count', /*sortable: true,*/ thStyle: 'width: 30%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          pairsFields: [
            // { key: 'pairKey', label: 'Pair Key', sortable: false, thStyle: 'width: 40%;', tdClass: 'text-truncate' },
            { key: 'baseSymbol', label: 'Base', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'baseName', label: 'Name', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'quoteSymbol', label: 'Quote', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'quoteName', label: 'Name', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'bestBidAmount', label: 'Amount', sortable: false, thStyle: 'width: 25%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'bestBid', label: 'Best Bid', sortable: false, thStyle: 'width: 25%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'bestOffer', label: 'Best Offer', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'bestOfferAmount', label: 'Amount', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          pairBuyOrdersFields: [
            { key: 'maker', label: 'Maker', sortable: false, thStyle: 'width: 25%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'expiry', label: 'Expiry', sortable: false, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'tokens', label: 'Amount', sortable: false, thStyle: 'width: 30%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'price', label: 'BUY Price', sortable: false, thStyle: 'width: 25%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          pairSellOrdersFields: [
            { key: 'price', label: 'SELL Price', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'tokens', label: 'Amount', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'expiry', label: 'Expiry', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'maker', label: 'Maker', sortable: false, thStyle: 'width: 25%;', tdClass: 'text-left' },
          ],
          pairHistoryFields: [
            { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'action', label: 'Action', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'taker', label: 'Taker', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'maker', label: 'Maker', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'base', label: 'Base', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'quote', label: 'Quote', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'price', label: 'Price', sortable: false, thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'tokens', label: 'Base Tokens', sortable: false, thStyle: 'width: 15%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'quoteTokens', label: 'Quote Tokens', sortable: false, thStyle: 'width: 15%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          tokensFields: [
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 7%;', tdClass: 'text-truncate' },
            { key: 'symbol', label: 'Symbol', sortable: false, thStyle: 'width: 7%;', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 13%;', tdClass: 'text-truncate' },
            { key: 'decimals', label: 'Decs', sortable: false, thStyle: 'width: 5%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'allowance', label: 'Allowance', sortable: false, thStyle: 'width: 17%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'balance', label: 'Balance', sortable: false, thStyle: 'width: 17%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'totalSupply', label: 'Total Supply', sortable: false, thStyle: 'width: 17%;', thClass: 'text-right', tdClass: 'text-right' },
            // { key: 'sync', label: 'Sync', sortable: false, thStyle: 'width: 7%;', tdClass: 'text-truncate' },
            // { key: 'include', label: 'Include', sortable: false, thStyle: 'width: 7%;', tdClass: 'text-truncate' },
            { key: 'getSome', label: 'Get Some', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'delete', label: 'Delete', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
          ],
          accountsFields: [
            { key: 'address', label: '#', sortable: false, thStyle: 'width: 30%;', tdClass: 'text-truncate' },
            { key: 'group', label: 'Group', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 40%;', tdClass: 'text-truncate' },
            { key: 'delete', label: 'Delete', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
          ],
          transfersFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            // { key: 'blockNumber', label: 'Block Number', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'info', label: 'Info', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            // { key: 'coin', label: 'Coin', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'from', label: 'From', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'to', label: 'To', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'tokens', label: 'Tokens', sortable: false, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'token', label: 'Token', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'rate', label: 'Rate', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
          ],
          groupsFilterFields: [
            { key: 'select', label: '', thStyle: 'width: 15%;' },
            { key: 'group', label: 'Group', sortable: true, tdClass: 'text-truncate' },
            { key: 'count', label: '#', sortable: true, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          accountsFilterFields: [
            { key: 'select', label: '', thStyle: 'width: 15%;' },
            { key: 'account', label: 'Account', sortable: true, tdClass: 'text-truncate' },
            { key: 'count', label: '#', sortable: true, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          collectionsFilterFields: [
            { key: 'select', label: '', thStyle: 'width: 15%;' },
            { key: 'collectionName', label: 'Collection', sortable: true, tdClass: 'text-truncate' },
            { key: 'count', label: '#', sortable: true, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          accountsImportAddressesFields: [
            { key: 'address', label: 'Address', sortable: true, thStyle: 'width: 60%;', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: true, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'group', label: 'Group', sortable: true, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            // { key: 'sync', label: 'Sync', sortable: true, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            // { key: 'include', label: 'Include', sortable: true, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
          ],
          transactionTypes: {
            1: "Transfer",
            21: "U2Mint",
            22: "U2Swap",
            23: "U2Burn",
            31: "U3Mint",
            32: "U3Swap",
            33: "U3Burn",
            34: "U3Collect",
          },
          indexToEventTypes: [
            "Assign",
            "Transfer",
            "Approve",
            "PunkOffered",
            "PunkBidEntered",
            "PunkNoLongerForSale",
            "PunkBought",
            "PunkBidWithdrawn",
            "PunkTransfer",
            "Approval",
            "ApprovalForAll",
            "OwnershipTransferred",
            "ProxyRegistered",
          ],
          db: {
            name: "cryptopunksdata088d",
            version: 1,
            schemaDefinition: {
              cache: '&objectName',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {
          eventTypesToIndex() {
            const results = {};
            for (const [eventTypeIndex, eventType] of this.indexToEventTypes.entries()) {
              results[eventType] = eventTypeIndex;
            }
            return results;
          },
          chadexAddress() {
            return CHADEXADDRESS_SEPOLIA;
          },
          pairsOptions() {
            const results = [ { value: null, text: '(select)' } ];
            for (const item of this.filteredPairs) {
              results.push({ value: item.pairKey, text: item.baseSymbol + '/' + item.quoteSymbol });
            }
            return results;
          },
          getSelectedPair() {
            const selectedPair = this.settings.pairTable.selectedPair;
            if (selectedPair) {
              const selectedPairIndex = this.pairToIndex[selectedPair];
              const pair = this.indexToPair[selectedPairIndex];
              return pair;
            }
            return null;
          },
          getSelectedBaseSymbol() {
            const selectedPair = this.getSelectedPair;
            if (selectedPair) {
              const token = this.tokens[selectedPair.baseIndex];
              return token.symbol;
            }
            return "(unknown)";
          },
          getSelectedQuoteSymbol() {
            const selectedPair = this.getSelectedPair;
            if (selectedPair) {
              const token = this.tokens[selectedPair.quoteIndex];
              return token.symbol;
            }
            return "(unknown)";
          },
          getAllGroups() {
            const groupsMap = {};
            for (const token of this.filteredTransfers) {
              const accountInfo = this.settings.accounts[token.owner] || {};
              const group = accountInfo.group || "(blank)";
              if (!(group in groupsMap)) {
                groupsMap[group] = 0;
              }
              groupsMap[group]++;
            }
            const results = [];
            for (const [group, count] of Object.entries(groupsMap)) {
              results.push({ group, count });
            }
            results.sort((a, b) => {
              if (('' + a.group).localeCompare(b.group) == 0) {
                results.sort((a, b) => a.count - b.count);
              } else {
                return ('' + a.group).localeCompare(b.group);
              }
            });
            return results;
          },
          getAllAccounts() {
            const accountsMap = {};
            for (const token of this.filteredTransfers) {
              if (!(token.owner in accountsMap)) {
                accountsMap[token.owner] = 0;
              }
              accountsMap[token.owner]++;
            }
            const results = [];
            for (const [account, count] of Object.entries(accountsMap)) {
              const accountInfo = this.settings.accounts[account] || {};
              const accountName = accountInfo.name && (accountInfo.name + ' ' + account.substring(0, 8)) || account.substring(0, 16);
              results.push({ account, accountName, count });
            }
            results.sort((a, b) => {
              if (('' + a.accountName).localeCompare(b.accountName) == 0) {
                results.sort((a, b) => a.count - b.count);
              } else {
                return ('' + a.accountName).localeCompare(b.accountName);
              }
            });
            return results;
          },
          getAllPools() {
            const collectionsMap = {};
            for (const token of this.filteredTransfers) {
              if (!(token.contract in collectionsMap)) {
                collectionsMap[token.contract] = 0;
              }
              collectionsMap[token.contract]++;
            }
            const results = [];
            for (const [contract, count] of Object.entries(collectionsMap)) {
              const collectionInfo = this.collections[contract] || {};
              results.push({ collection: contract, collectionName: collectionInfo.name, count });
            }
            results.sort((a, b) => {
              if (('' + a.collectionName).localeCompare(b.collectionName) == 0) {
                results.sort((a, b) => a.count - b.count);
              } else {
                return ('' + a.collectionName).localeCompare(b.collectionName);
              }
            });
            return results;
          },
          newCoinAddressState() {
            if (this.newCoinAddress) {
              try {
                const a = ethers.utils.getAddress(this.newCoinAddress);
                return a && a.length > 0;
              } catch (e) {
                return false;
              }
            }
            return null;
          },
          newAddressState() {
            if (this.newAddress) {
              try {
                const a = ethers.utils.getAddress(this.newAddress);
                return a && a.length > 0;
              } catch (e) {
                return false;
              }
            }
            return null;
          },
          allowanceAmountState() {
            if (this.allowanceFormData.amount) {
              if (/^[+-]?\d+(\.\d+)?$/.test(this.allowanceFormData.amount)) {
                try {
                  const a = !isNaN(parseFloat(this.allowanceFormData.amount));
                  console.log("allowanceAmountState: " + a);
                  return a;
                } catch (e) {
                  return false;
                }
              } else {
                return false;
              }
            }
            return null;
          },
          wethAmountState() {
            if (this.wethFormData.amount) {
              if (/^[+-]?\d+(\.\d+)?$/.test(this.wethFormData.amount)) {
                try {
                  const a = !isNaN(parseFloat(this.wethFormData.amount));
                  console.log("wethAmountState: " + a);
                  return a;
                } catch (e) {
                  return false;
                }
              } else {
                return false;
              }
            }
            return null;
          },
          punkAttributes() {
            return PUNKATTRIBUTES;
          },
          punkAttributesWithTokenIds() {
            const collator = {};
            for (const [punkId, punkAttribute] of this.punkAttributes.entries()) {
              for (const attribute of punkAttribute) {
                const trait_type = attribute.trait_type;
                const value = attribute.value;
                if (!collator[trait_type]) {
                  collator[trait_type] = {};
                }
                if (!collator[trait_type][value]) {
                  collator[trait_type][value] = [punkId];
                } else {
                  collator[trait_type][value].push(punkId);
                }
              }
            }
            const results = [];
            for (const [attributeType, attributes] of Object.entries(collator)) {
              const attributeList = [];
              for (const [attribute, punks] of Object.entries(attributes)) {
                attributeList.push({ attribute, punks });
              }
              attributeList.sort((a, b) => a.punks.length - b.punks.length);
              results.push({ attributeType, attributeList });
            }
            results.sort((a, b) => ('' + a.attributeType).localeCompare(b.attributeType))
            return results;
          },
          filteredPunks() {
            const results = [];
            // console.log("filteredPunks - this.settings.filters: " + JSON.stringify(this.settings.filters));
            let stage1Data = this.punkAttributes;
            if (Object.keys(this.settings.filters).length == 0) {
              for (const [punkId, attributes] of this.punkAttributes.entries()) {
                results.push({ punkId, attributes });
              }
            } else {
              let selectedTokenIds = [];
              for (const [attributeType, attributeList] of Object.entries(this.settings.filters)) {
                let thisAttributeTypeTokenIds = [];
                for (const attribute of Object.keys(attributeList)) {
                  for (const attributeInfo of this.punkAttributesWithTokenIds) {
                    if (attributeInfo.attributeType == attributeType) {
                      const tokenIds = attributeInfo.attributeList.filter(e => e.attribute == attribute).map(e => e.punks).flat();
                      thisAttributeTypeTokenIds = [...thisAttributeTypeTokenIds, ...tokenIds];
                      break;
                    }
                  }
                }
                if (selectedTokenIds.length == 0) {
                  selectedTokenIds = thisAttributeTypeTokenIds;
                } else {
                  selectedTokenIds = selectedTokenIds.filter(tokenId => thisAttributeTypeTokenIds.includes(tokenId));
                }
              }
              for (const punkId of selectedTokenIds) {
                results.push({ punkId, attributes: this.punkAttributes[punkId] });
              }
            }
            // console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " filteredPunks - results: " + JSON.stringify(results.slice(0, 10)) + ", ...");
            return results;
          },
          filteredSortedPunks() {
            let results = this.filteredPunks;
            if (this.settings.punksTable.sortOption == 'punkidasc') {
              results.sort((a, b) => {
                return a.punkId - b.punkId;
              });
            } else if (this.settings.punksTable.sortOption == 'punkiddsc') {
              results.sort((a, b) => {
                return b.punkId - a.punkId;
              });
            }
            return results;
          },
          pagedFilteredSortedPunks() {
            return this.filteredSortedPunks.slice((this.settings.punksTable.currentPage - 1) * this.settings.punksTable.pageSize, this.settings.punksTable.currentPage * this.settings.punksTable.pageSize);
          },

          filteredActivity() {
            const results = [];
            // console.log("filteredActivity - this.settings.filters: " + JSON.stringify(this.settings.filters));
            console.log(JSON.stringify(this.txs).substring(0, 1000));
            for (const [txHash, txInfo] of Object.entries(this.txs)) {
              results.push([ txHash, ...txInfo ]);
            }
            // let stage1Data = this.punkAttributes;
            // if (Object.keys(this.settings.filters).length == 0) {
            //   for (const [punkId, attributes] of this.punkAttributes.entries()) {
            //     results.push({ punkId, attributes });
            //   }
            // } else {
            //   let selectedTokenIds = [];
            //   for (const [attributeType, attributeList] of Object.entries(this.settings.filters)) {
            //     let thisAttributeTypeTokenIds = [];
            //     for (const attribute of Object.keys(attributeList)) {
            //       for (const attributeInfo of this.punkAttributesWithTokenIds) {
            //         if (attributeInfo.attributeType == attributeType) {
            //           const tokenIds = attributeInfo.attributeList.filter(e => e.attribute == attribute).map(e => e.punks).flat();
            //           thisAttributeTypeTokenIds = [...thisAttributeTypeTokenIds, ...tokenIds];
            //           break;
            //         }
            //       }
            //     }
            //     if (selectedTokenIds.length == 0) {
            //       selectedTokenIds = thisAttributeTypeTokenIds;
            //     } else {
            //       selectedTokenIds = selectedTokenIds.filter(tokenId => thisAttributeTypeTokenIds.includes(tokenId));
            //     }
            //   }
            //   for (const punkId of selectedTokenIds) {
            //     results.push({ punkId, attributes: this.punkAttributes[punkId] });
            //   }
            // }
            // console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " filteredActivity - results: " + JSON.stringify(results.slice(0, 10)) + ", ...");
            return results;
          },
          filteredSortedActivity() {
            let results = this.filteredActivity;
            console.log("filteredSortedActivity - sortOption: " + this.settings.activityTable.sortOption);
            console.log("filteredSortedActivity - results[0]: " + JSON.stringify(results[0]));
            if (this.settings.activityTable.sortOption == 'txorderasc') {
              results.sort((a, b) => {
                return a[1] - b[1];
              });
            } else if (this.settings.activityTable.sortOption == 'txorderdsc') {
              results.sort((a, b) => {
                return b[1] - a[1];
              });
            }
            console.log("filteredSortedActivity - results[0] sorted: " + JSON.stringify(results[0]));
            return results;
          },
          pagedFilteredSortedActivity() {
            return this.filteredSortedActivity.slice((this.settings.activityTable.currentPage - 1) * this.settings.activityTable.pageSize, this.settings.activityTable.currentPage * this.settings.activityTable.pageSize);
          },

          filteredPairs() {
            const results = [];
            const filterRegex = this.settings.pairsTable.filter && this.settings.pairsTable.filter.length > 0 ? new RegExp(this.settings.pairsTable.filter, 'i') : null;
            for (const pair of this.indexToPair) {
              const baseToken = this.tokens[pair.baseIndex] || {};
              const quoteToken = this.tokens[pair.quoteIndex] || {};
              let include = true;
              if (filterRegex) {
                if (!filterRegex.test(baseToken.symbol) && !filterRegex.test(baseToken.name) && !filterRegex.test(quoteToken.symbol) && !filterRegex.test(quoteToken.name)) {
                  include = false;
                }
              }
              if (include) {
                results.push({
                  pairKey: pair.pairKey,
                  baseIndex: pair.baseIndex,
                  baseToken: this.indexToAddress[pair.baseIndex],
                  baseSymbol: baseToken.symbol || "",
                  baseName: baseToken.name || "",
                  baseDecimals: baseToken.decimals,
                  quoteIndex: pair.quoteIndex,
                  quoteToken: this.indexToAddress[pair.quoteIndex],
                  quoteSymbol: quoteToken.symbol || "",
                  quoteName: quoteToken.name || "",
                  quoteDecimals: quoteToken.decimals,
                  multiplier: pair.multiplier,
                  divisor: pair.divisor,
                  bestBuyOrder: pair.bestBuyOrder,
                  bestSellOrder: pair.bestSellOrder,
                });
              }
            }
            // console.log("filteredPairs: " + JSON.stringify(results, null, 2))
            return results;
          },
          filteredSortedPairs() {
            let results = this.filteredPairs;
            // TODO
            return results;
          },
          pagedFilteredSortedPairs() {
            return this.filteredSortedPairs.slice((this.settings.pairsTable.currentPage - 1) * this.settings.pairsTable.pageSize, this.settings.pairsTable.currentPage * this.settings.pairsTable.pageSize);
          },
          filteredPairBuyOrders() {
            // console.log("filteredPairBuyOrders - pair: " + JSON.stringify(this.pair, null, 2));
            const results = [];
            if (this.settings.pairTable.selectedPair in this.pair) {
              const pair = this.pair[this.settings.pairTable.selectedPair];
              if ('0' in pair) {
                for (const [orderIndex, order] of pair[0].entries()) {
                  results.push({
                    price: order.price,
                    orderIndex,
                    orderKey: order.orderKey,
                    nextOrderKey: order.nextOrderKey,
                    makerIndex: order.makerIndex,
                    expiry: order.expiry,
                    originalTokens: order.originalTokens,
                    tokens: order.tokens,
                    filled: order.filled,
                    availableBase: order.availableBase,
                    availableQuote: order.availableQuote,
                    _rowVariant: order.orderKey in this.selectedBuyOrders ? 'primary' : undefined,
                  });
                }
              }
            }
            return results;
          },
          filteredPairSellOrders() {
            // console.log("filteredPairSellOrders");
            const results = [];
            if (this.settings.pairTable.selectedPair in this.pair) {
              const pair = this.pair[this.settings.pairTable.selectedPair];
              if ('1' in pair) {
                for (const [orderIndex, order] of pair[1].entries()) {
                  results.push({
                    price: order.price,
                    orderIndex,
                    orderKey: order.orderKey,
                    nextOrderKey: order.nextOrderKey,
                    makerIndex: order.makerIndex,
                    expiry: order.expiry,
                    originalTokens: order.originalTokens,
                    tokens: order.tokens,
                    filled: order.filled,
                    availableBase: order.availableBase,
                    availableQuote: order.availableQuote,
                    _rowVariant: order.orderKey in this.selectedSellOrders ? 'primary' : undefined,
                  });
                }
              }
            }
            return results;
          },
          filteredPairHistory() {
            // console.log("filteredPairHistory");

            const selectedPairIndex = this.settings.tabIndex == 1 ? null : this.pairToIndex[this.settings.pairTable.selectedPair];
            console.log("selectedPairIndex: " + selectedPairIndex);
// (settings.tabIndex == 1 || settings.tabIndex == 2)
//
//             const pairIndex = this.pairToIndex[this.settings.pairTable.selectedPair];
            // const pair = this.indexToPair[pairIndex] || {};



            // console.log("filteredPairHistory - pairIndex: " + pairIndex);
            // console.log("filteredPairHistory - pair: " + JSON.stringify(pair, null, 2).substring(0, 2000));

            // console.log("filteredPairHistory - this.events: " + JSON.stringify(this.events, null, 2).substring(0, 2000));

            const results = [];
            for (const [blockNumber, txIndexes] of Object.entries(this.events)) {
              for (const [txIndex, txHashes] of Object.entries(txIndexes)) {
                for (const [txHash, logIndexes] of Object.entries(txHashes)) {
                  for (const [logIndex, txInfo] of Object.entries(logIndexes)) {
                    // console.log("blockNumber: " + blockNumber + "/" + txIndex + "/" + txHash + "/" + logIndex + " => " + JSON.stringify(txInfo, null, 2));
                    const pairIndex = txInfo[0];
                    const pair = this.indexToPair[pairIndex];
                    if (selectedPairIndex == null || selectedPairIndex == pairIndex) {
                      const timestamp = txInfo[1];
                      const eventType = txInfo[2];
                      results.push({
                        blockNumber,
                        timestamp,
                        txIndex,
                        txHash,
                        logIndex,
                        pairIndex,
                        baseIndex: pair.baseIndex,
                        quoteIndex: pair.quoteIndex,
                        baseDecimals: pair.baseDecimals,
                        quoteDecimals: pair.quoteDecimals,
                        baseSymbol: pair.baseSymbol, // TODO
                        quoteSymbol: pair.quoteSymbol, // TODO
                        eventType,
                        txInfo
                      });
                    }
                  }
                }
              }
            }
            // console.log("filteredPairHistory - results: " + JSON.stringify(results, null, 2).substring(0, 1000));

            if (false && this.settings.pairTable.selectedPair in this.pair) {
              const pair = this.pair[this.settings.pairTable.selectedPair];
              if ('history' in pair) {
                for (const [itemIndex, item] of pair.history.entries()) {
                  // console.log(itemIndex + " " + JSON.stringify(item));
                  results.push({
                    // txHash: item.txHash,
                    // blockNumber: item.blockNumber,
                    // action: item.action,
                    ...item,
                  //   price: order.price,
                  //   orderIndex,
                  //   orderKey: order.orderKey,
                  //   nextOrderKey: order.nextOrderKey,
                  //   maker: order.maker,
                  //   expiry: order.expiry,
                  //   tokens: order.tokens,
                  //   filled: order.filled,
                  //   availableBase: order.availableBase,
                  //   availableQuote: order.availableQuote,
                  });
                }
              }
            }
            // console.log("filteredPairHistory: " + JSON.stringify(results, null, 2));
            return results;
          },
          filteredSortedPairBuyOrders() {
            let results = this.filteredPairBuyOrders;
            // TODO
            return results;
          },
          filteredSortedPairSellOrders() {
            let results = this.filteredPairSellOrders;
            // TODO
            return results;
          },
          filteredSortedPairHistory() {
            let results = this.filteredPairHistory;
            results.sort((a, b) => {
              if (a.blockNumber == b.blockNumber) {
                if (a.transactionIndex == b.transactionIndex) {
                  return a.logIndex - b.logIndex;
                } else {
                  return a.transactionIndex - b.transactionIndex;
                }
              } else {
                return b.blockNumber - a.blockNumber;
              }
            });
            return results;
          },
          pagedFilteredSortedPairBuyOrders() {
            return this.filteredSortedPairBuyOrders.slice((this.settings.pairTable.buyOrders.currentPage - 1) * this.settings.pairTable.buyOrders.pageSize, this.settings.pairTable.buyOrders.currentPage * this.settings.pairTable.buyOrders.pageSize);
          },
          pagedFilteredSortedPairSellOrders() {
            return this.filteredSortedPairSellOrders.slice((this.settings.pairTable.sellOrders.currentPage - 1) * this.settings.pairTable.sellOrders.pageSize, this.settings.pairTable.sellOrders.currentPage * this.settings.pairTable.sellOrders.pageSize);
          },
          pagedFilteredSortedPairHistory() {
            return this.filteredSortedPairHistory.slice((this.settings.pairTable.history.currentPage - 1) * this.settings.pairTable.history.pageSize, this.settings.pairTable.history.currentPage * this.settings.pairTable.history.pageSize);
          },
          // pagedFilteredSortedPairHistory() {
          //   return this.filteredSortedPairHistory.slice((this.settings.pairTable.history.currentPage - 1) * this.settings.pairTable.history.pageSize, this.settings.pairTable.history.currentPage * this.settings.pairTable.history.pageSize);
          // },
          filteredTokens() {
            const results = [];
            const filterRegex = this.settings.tokensTable.filter && this.settings.tokensTable.filter.length > 0 ? new RegExp(this.settings.tokensTable.filter, 'i') : null;
            for (const [address, item] of Object.entries(this.settings.tokens)) {
              let include = true;
              if (filterRegex) {
                if (!filterRegex.test(item.name) && !filterRegex.test(item.group) && !filterRegex.test(address)) {
                  include = false;
                }
              }
              if (include) {
                results.push({
                  address,
                  symbol: item.symbol,
                  name: item.name,
                  decimals: item.decimals,
                  allowance: item.allowance,
                  balance: item.balance,
                  totalSupply: item.totalSupply,
                  sync: item.sync,
                  include: item.include,
                  latestBlockNumber: item.latestBlockNumber,
                });
              }
            }
            return results;
          },
          filteredSortedTokens() {
            let results = this.filteredTokens;
            console.log("filteredSortedTokens: " + JSON.stringify(results, null, 2));
            return results;
          },
          pagedFilteredSortedTokens() {
            return this.filteredSortedTokens.slice((this.settings.tokensTable.currentPage - 1) * this.settings.tokensTable.pageSize, this.settings.tokensTable.currentPage * this.settings.tokensTable.pageSize);
          },
          filteredAccounts() {
            const results = [];
            const filterRegex = this.settings.accountsTable.filter && this.settings.accountsTable.filter.length > 0 ? new RegExp(this.settings.accountsTable.filter, 'i') : null;
            for (const [address, item] of Object.entries(this.settings.accounts)) {
              let include = true;
              if (filterRegex) {
                if (!filterRegex.test(item.name) && !filterRegex.test(item.group) && !filterRegex.test(address)) {
                  include = false;
                }
              }
              if (include) {
                results.push({
                  address,
                  name: item.name,
                  group: item.group,
                });
              }
            }
            return results;
          },
          filteredSortedAccounts() {
            let results = this.filteredAccounts;
            if (this.settings.accountsTable.sortOption == 'groupnameasc') {
              results.sort((a, b) => {
                if (('' + a.group).localeCompare(b.group) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.account).localeCompare(b.account);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + a.group).localeCompare(b.group);
                }
              });
            } else if (this.settings.accountsTable.sortOption == 'groupnamedsc') {
              results.sort((a, b) => {
                if (('' + a.group).localeCompare(b.group) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.account).localeCompare(b.account);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + b.group).localeCompare(a.group);
                }
              });
            } else if (this.settings.accountsTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + a.account).localeCompare(b.account);
                } else {
                  return ('' + a.name).localeCompare(b.name);
                }
              });
            } else if (this.settings.accountsTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + a.account).localeCompare(b.account);
                } else {
                  return ('' + b.name).localeCompare(a.name);
                }
              });
            } else {
              results.sort((a, b) => {
                if (('' + a.group).localeCompare(b.group) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.account).localeCompare(b.account);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + a.group).localeCompare(b.group);
                }
              });
            }
            return results;
          },
          pagedFilteredSortedAccounts() {
            return this.filteredSortedAccounts.slice((this.settings.accountsTable.currentPage - 1) * this.settings.accountsTable.pageSize, this.settings.accountsTable.currentPage * this.settings.accountsTable.pageSize);
          },
          filteredTransfers() {
            console.log(moment().format("HH:mm:ss") + " filteredTransfers");
            // console.log("pools: " + JSON.stringify(this.pools. null, 2));
            // console.log("trades: " + JSON.stringify(this.trades, null, 2));
            // const tokenFilterRegex = this.settings.tokensTable.tokenFilter && this.settings.tokensTable.tokenFilter.length > 0 ? new RegExp(this.settings.tokensTable.tokenFilter, 'i') : null;
            // const searchCollectionLower = this.settings.tokensTable.collectionfilter && this.settings.tokensTable.collectionfilter.toLowerCase() || null;
            // let groupFilter = null;
            // if (this.settings.filters.groups && Object.keys(this.settings.filters.groups).length > 0) {
            //   groupFilter = this.settings.filters.groups;
            // }
            // let accountFilter = null;
            // if (this.settings.filters.accounts && Object.keys(this.settings.filters.accounts).length > 0) {
            //   accountFilter = this.settings.filters.accounts;
            // }
            // let collectionFilter = null;
            // if (this.settings.filters.collections && Object.keys(this.settings.filters.collections).length > 0) {
            //   collectionFilter = this.settings.filters.collections;
            // }
            const results = [];
            // console.log("this.trades: " + JSON.stringify(this.trades, null, 2));
            // multi for (const [txHash, txInfo] of Object.entries(this.trades).slice(900, 950)) {
            for (const [txHash, txInfo] of Object.entries(this.trades)) {
              // const timestamp = this.blockTimestamps[txInfo.blockNumber] || null;

              // console.log(txHash + " => " + JSON.stringify(txInfo, null, 2));
              const [blockNumber, timestamp, txIndex, isDex, logs] = txInfo;

              let actions = null;
              // const sortedLogs = [];

              // console.log("txInfo.logs: " + JSON.stringify(txInfo.logs, null, 2));
              // for (const [logIndex, logInfo] of Object.entries(txInfo.logs)) {
              //   const [type, tokenIndex, fromIndex, toIndex, tokens ] = logInfo;
              //   sortedLogs.push({ logIndex, type, tokenIndex, fromIndex, toIndex, tokens });
              // }

              // for (const row of txInfo[4]) {
              //   sortedLogs.push(row);
              // }
              if (logs.length > 1) {
                logs.sort((a, b) => {
                  return a[0] - b[0];
                });
              }
              // console.log("logs: " + JSON.stringify(logs, null, 2));

              // const txLogs = logs.filter(e => e[1] == "tx");
              // console.log("txLogs: " + JSON.stringify(txLogs));

              // const altTxLogs = sortedLogs.filter(e => e.type == "alttx");
              // const uLogs = sortedLogs.filter(e => e[1] == "swap" || e[1] == "mint" || e[1] == "burn" || e[1] == "collect");
              // console.log("uLogs: " + JSON.stringify(uLogs));

              // const u2Logs = sortedLogs.filter(e => e.source == "u2");
              // const u3Logs = sortedLogs.filter(e => e.source == "u3");
              // console.log("sortedLogs: " + JSON.stringify(sortedLogs, null, 2));
              // console.log("altTxLogs: " + JSON.stringify(altTxLogs, null, 2));
              // console.log("u2Logs: " + JSON.stringify(u2Logs, null, 2));
              // console.log("u3Logs: " + JSON.stringify(u3Logs, null, 2));

              if (!isDex) {
                actions = logs;
                // actions = [];
                // for (const log of logs) {
                //   // const tokenIndex = log[5];
                //   // const tokenAddress = this.indexToAddress[tokenIndex];
                //   // const tokenSymbol = this.settings.tokens[tokenAddress] && this.settings.tokens[tokenAddress].symbol || null;
                //   // const decimals = this.settings.tokens[tokenAddress] && this.settings.tokens[tokenAddress].decimals || 18;
                //   // actions.push([ log[0], log[1], tokenAddress, tokenSymbol, decimals, this.indexToAddress[log[3]], this.indexToAddress[log[4]], log[5] ]);
                //   actions.push([ ...log, /*tokenSymbol, decimals*/ ]);
                // }
              } else if (isDex) {
                actions = logs;
              } else if (uLogs.length > 0 && false) {
                // console.log("uLogs: " + JSON.stringify(uLogs));
                actions = [];
                for (const log of uLogs) {
                  // console.log("log: " + JSON.stringify(log));
                  if (log[1] == "mint") {
                    const pool = this.pools[this.indexToAddress[log[log.length - 1]]] || null;
                    // console.log("pool: " + JSON.stringify(pool, null, 2));
                    const token0 = {
                      token: pool.token0.symbol,
                      decimals: pool.token0.decimals,
                      tokens: ethers.BigNumber.from(log[3]).mul(-1).toString(),
                    };
                    const token1 = {
                      token: pool.token1.symbol,
                      decimals: pool.token1.decimals,
                      tokens: ethers.BigNumber.from(log[4]).mul(-1).toString(),
                    };
                    // console.log("token0: " + JSON.stringify(token0));
                    // console.log("token1: " + JSON.stringify(token1));
                    const TENMINUS18 = ethers.BigNumber.from(10).pow(18).mul(-1);
                    let rate;
                    if (pool.coin == pool.token0.address) {
                      if (!ethers.BigNumber.from(token0.tokens).eq(0)) {
                        rate = ethers.BigNumber.from(token1.tokens).mul(TENMINUS18).div(ethers.BigNumber.from(token0.tokens)).toString();
                      }
                    } else {
                      if (!ethers.BigNumber.from(token1.tokens).eq(0)) {
                        rate = ethers.BigNumber.from(token0.tokens).mul(TENMINUS18).div(ethers.BigNumber.from(token1.tokens)).toString();
                      }
                    }
                    actions.push([ log[0], log[1], log[2], log[6],
                      log[3], this.addressToIndex[pool.token0.address], pool.token0.symbol, pool.token0.decimals,
                      log[4], this.addressToIndex[pool.token1.address], pool.token1.symbol, pool.token1.decimals,
                      rate ]);

                  } else if (log[1] == "swap") {
                    const pool = this.pools[this.indexToAddress[log[7]]] || null;
                    const token0 = {
                      token: pool.token0.symbol,
                      decimals: pool.token0.decimals,
                      tokens: ethers.BigNumber.from(log[4]).mul(-1).toString(),
                    };
                    const token1 = {
                      token: pool.token1.symbol,
                      decimals: pool.token1.decimals,
                      tokens: ethers.BigNumber.from(log[5]).mul(-1).toString(),
                    };
                    let tradeType;
                    let rate = null;
                    const TENMINUS18 = ethers.BigNumber.from(10).pow(18).mul(-1);
                    if (pool.coin == pool.token0.address) {
                      if (ethers.BigNumber.from(token0.tokens).gt(0)) {
                        tradeType = "Buy " + pool.token0.symbol;
                      } else {
                        tradeType = "Sell " + pool.token0.symbol;
                      }
                      if (!ethers.BigNumber.from(token0.tokens).eq(0)) {
                        rate = ethers.BigNumber.from(token1.tokens).mul(TENMINUS18).div(ethers.BigNumber.from(token0.tokens)).toString();
                      }
                    } else {
                      if (ethers.BigNumber.from(token1.tokens).gt(0)) {
                        tradeType = "Buy " + pool.token1.symbol;
                      } else {
                        tradeType = "Sell " + pool.token1.symbol;
                      }
                      if (!ethers.BigNumber.from(token1.tokens).eq(0)) {
                        rate = ethers.BigNumber.from(token0.tokens).mul(TENMINUS18).div(ethers.BigNumber.from(token1.tokens)).toString();
                      }
                    }
                    actions.push([ log[0], log[1], log[3], log[7],
                      log[4], this.addressToIndex[pool.token0.address], pool.token0.symbol, pool.token0.decimals,
                      log[5], this.addressToIndex[pool.token1.address], pool.token1.symbol, pool.token1.decimals,
                      rate, log[6] ]);
                  } else if (log[3] == "burn") {
                    // console.log("logData: " + JSON.stringify(logData, null, 2));
                    actions.push({
                      type: "Burn",
                      logData,
                      // tradeType,
                      // token0,
                      // token1,
                      // from: logData.recipient,
                      // to: logData.poolAddress,
                    });
                  } else if (log[3] == "collect") {
                    const token0 = {
                      token: pool.token0.symbol,
                      decimals: pool.token0.decimals,
                      tokens: ethers.BigNumber.from(logData.amount0).mul(-1).toString(),
                    };
                    const token1 = {
                      token: pool.token1.symbol,
                      decimals: pool.token1.decimals,
                      tokens: ethers.BigNumber.from(logData.amount1).mul(-1).toString(),
                    };
                    const TENMINUS18 = ethers.BigNumber.from(10).pow(18).mul(-1);
                    let rate;
                    if (pool.coin == pool.token0.address) {
                      if (!ethers.BigNumber.from(token0.tokens).eq(0)) {
                        rate = ethers.BigNumber.from(token1.tokens).mul(TENMINUS18).div(ethers.BigNumber.from(token0.tokens)).toString();
                      }
                    } else {
                      if (!ethers.BigNumber.from(token1.tokens).eq(0)) {
                        rate = ethers.BigNumber.from(token0.tokens).mul(TENMINUS18).div(ethers.BigNumber.from(token1.tokens)).toString();
                      }
                    }
                    actions.push({
                      type: "Collect",
                      token0,
                      token1,
                      from: logData.poolAddress,
                      to: logData.recipient,
                      rate,
                    });
                  }
                }
              }
              // if (actions && actions.type == "trade") {
              // if (uLogs.length == 1 && txHash == "0x9f22ce032b8ff79fccd20f3465d0a09efc293afac3936035de5d7496276cb1eb") {
              // if (uLogs.length == 0 && txLogs.length > 1) {
              // if (txHash == "0x222c541878cf98dacd004e833bfa63a661521679c9c90a970ed47b1cd0d1e3b0") {
                results.push([
                  txHash,
                  blockNumber,
                  timestamp,
                  txIndex,
                  // txInfo.token,
                  // logs: txInfo.logs,
                  actions,
                ]);
                // console.log("results: " + JSON.stringify(results, null, 2));
              // }
            }
            // console.log("results[0]: " + JSON.stringify(results && results[0] || {}));
            // for (const [blockNumber, txIndexes] of Object.entries(this.transfers)) {
            //   const timestamp = this.blockTimestamps[blockNumber] || null;
            //   for (const [txIndex, txHashes] of Object.entries(txIndexes)) {
            //     for (const [txHash, logIndexes] of Object.entries(txHashes)) {
            //       for (const [logIndex, txData] of Object.entries(logIndexes)) {
            //         results.push({ blockNumber, timestamp, txIndex, txHash, logIndex, coin: txData.address, from: txData.from, to: txData.to, tokens: txData.tokens });
            //       }
            //     }
            //   }
            // //   let include = true;
            // //   const collectionName = this.collections[token.contract] && this.collections[token.contract].name || null;
            // //   if (tokenFilterRegex) {
            // //     if (!tokenFilterRegex.test(token.name) && !tokenFilterRegex.test(token.tokenId.toString())) {
            // //       include = false;
            // //     }
            // //   }
            // //   if (include && searchCollectionLower) {
            // //     if (!(collectionName && collectionName.toLowerCase().includes(searchCollectionLower))) {
            // //       include = false;
            // //     }
            // //   }
            // //   if (include && groupFilter) {
            // //     const accountInfo = this.settings.accounts[token.owner] || {};
            // //     const group = accountInfo.group || "(blank)";
            // //     if (!(group in groupFilter)) {
            // //       include = false;
            // //     }
            // //   }
            // //   if (include && accountFilter) {
            // //     if (!(token.owner in accountFilter)) {
            // //       include = false;
            // //     }
            // //   }
            // //   if (include && collectionFilter) {
            // //     if (!(token.contract in collectionFilter)) {
            // //       include = false;
            // //     }
            // //   }
            // //   if (include) {
            // //     const ownerInfo = this.settings.accounts[token.owner] || {};
            // //     const ownerName = ownerInfo.name && (ownerInfo.name + ' ' + token.owner.substring(0, 8)) || token.owner.substring(0, 16);
            // //     results.push({
            // //       ...token,
            // //       ownerName,
            // //       collectionName,
            // //       lastSale: {
            // //         timestamp: token.lastSale && token.lastSale.timestamp || null,
            // //         amount: token.lastSale && token.lastSale.price && token.lastSale.price.amount && token.lastSale.price.amount.native || null,
            // //         currency: token.lastSale && token.lastSale.price && token.lastSale.price.currency && token.lastSale.price.currency.symbol || null,
            // //         amountInUSD: token.lastSale && token.lastSale.price && token.lastSale.price.amount && token.lastSale.price.amount.usd || null,
            // //       },
            // //     });
            // //   }
            // }
            console.log(moment().format("HH:mm:ss") + " filteredTransfers END");
            return results;
          },
          filteredSortedTransfers() {
            let results = this.filteredTransfers;
            if (this.settings.transfersTable.sortOption == 'blocknumberasc') {
              results.sort((a, b) => {
                if (a[1] == b[1]) {
                  return a[3] - b[3];
                } else {
                  return a[1] - b[1];
                }
              });
            } else if (this.settings.transfersTable.sortOption == 'blocknumberdsc') {
              results.sort((a, b) => {
                if (a[1] == b[1]) {
                  return b[3] - a[3];
                } else {
                  return b[1] - a[1];
                }
              });
            }
            return results;
          },
          pagedFilteredSortedTransfers() {
            return this.filteredSortedTransfers.slice((this.settings.transfersTable.currentPage - 1) * this.settings.transfersTable.pageSize, this.settings.transfersTable.currentPage * this.settings.transfersTable.pageSize);
          },
        },

        // --- METHODS ---
        methods: {
          slugToTitle(slug) {
            var words = slug.toString().split("-");
            return words.map(function(word) {
              if (word == "3d" || word == "vr") {
                return word.toUpperCase();
              } else {
                return word.charAt(0).toUpperCase() + word.substring(1).toLowerCase();
              }
            }).join(' ');
          },
          pairsRowSelected(items) {
            console.log("pairsRowSelected: " + JSON.stringify(items));
            const pairKey = items[0].pairKey;
            this.settings.pairTable.selectedPair = pairKey;
            this.settings.tabIndex = 2;
          },
          pairBuyRowSelected(items) {
            console.log("pairBuyRowSelected: " + JSON.stringify(items));
            const selectedBuyOrders = {};
            if (items.length > 0) {
              const selectedPair = this.settings.pairTable.selectedPair;
              const selectedPairIndex = this.pairToIndex[selectedPair];
              const pair = this.indexToPair[selectedPairIndex];
              const orderKey = items[0].orderKey;
              let tokens = ZERO;
              let quoteTokens = ZERO;
              let averagePrice = ZERO;
              for (const order of this.pagedFilteredSortedPairBuyOrders) {
                console.log(JSON.stringify(order));
                tokens = tokens.add(order.tokens);
                quoteTokens = quoteTokens.add(ethers.BigNumber.from(order.tokens).mul(TEN.pow(pair.divisor)).mul(order.price).div(TEN.pow(pair.multiplier + PRICE_DECIMALS)));
                averagePrice = tokens.isZero() ? ZERO : quoteTokens.mul(TEN.pow(pair.multiplier + PRICE_DECIMALS)).div(tokens).div(TEN.pow(pair.divisor));
                console.log("tokens: " + ethers.utils.formatEther(tokens) + ", quoteTokens: " + ethers.utils.formatEther(quoteTokens) +", averagePrice: " + ethers.utils.formatUnits(averagePrice, 12));
                selectedBuyOrders[order.orderKey] = true;
                if (order.orderKey == orderKey) {
                  break;
                }
              }
              if (!tokens.isZero() || !quoteTokens.isZero()) {
                Vue.set(this.sell, 'tokens', ethers.utils.formatUnits(tokens, 18));
                Vue.set(this.sell, 'quoteTokens', ethers.utils.formatUnits(quoteTokens, 18));
                Vue.set(this.sell, 'price', ethers.utils.formatUnits(items[0].price, 12));
                Vue.set(this.sell, 'targetPrice', ethers.utils.formatUnits(averagePrice, 12));
              }
            }
            Vue.set(this, 'selectedBuyOrders', selectedBuyOrders);
            console.log("selectedBuyOrders: " + JSON.stringify(selectedBuyOrders));
          },
          pairSellRowSelected(items) {
            console.log("pairSellRowSelected: " + JSON.stringify(items));
            const selectedSellOrders = {};
            if (items.length > 0) {
              const selectedPair = this.settings.pairTable.selectedPair;
              const selectedPairIndex = this.pairToIndex[selectedPair];
              const pair = this.indexToPair[selectedPairIndex];
              const orderKey = items[0].orderKey;
              let tokens = ZERO;
              let quoteTokens = ZERO;
              let averagePrice = ZERO;
              for (const order of this.pagedFilteredSortedPairSellOrders) {
                console.log(JSON.stringify(order));
                tokens = tokens.add(order.tokens);
                quoteTokens = quoteTokens.add(ethers.BigNumber.from(order.tokens).mul(TEN.pow(pair.divisor)).mul(order.price).div(TEN.pow(pair.multiplier + PRICE_DECIMALS)));
                averagePrice = tokens.isZero() ? ZERO : quoteTokens.mul(TEN.pow(pair.multiplier + PRICE_DECIMALS)).div(tokens).div(TEN.pow(pair.divisor));
                console.log("tokens: " + ethers.utils.formatEther(tokens) + ", quoteTokens: " + ethers.utils.formatEther(quoteTokens) +", averagePrice: " + ethers.utils.formatUnits(averagePrice, 12));
                selectedSellOrders[order.orderKey] = true;
                if (order.orderKey == orderKey) {
                  break;
                }
              }
              if (!tokens.isZero() || !quoteTokens.isZero()) {
                Vue.set(this.buy, 'tokens', ethers.utils.formatUnits(tokens, 18));
                Vue.set(this.buy, 'quoteTokens', ethers.utils.formatUnits(quoteTokens, 18));
                Vue.set(this.buy, 'price', ethers.utils.formatUnits(items[0].price, 12));
                Vue.set(this.buy, 'targetPrice', ethers.utils.formatUnits(averagePrice, 12));
              }
            }
            Vue.set(this, 'selectedSellOrders', selectedSellOrders);
            console.log("selectedSellOrders: " + JSON.stringify(selectedSellOrders));
          },
          checkValidPrice(p) {
            if (p) {
              const stripped = p.replace(/[,_]/g,"");
              if (/^[+-]?\d{0,12}(\.\d{0,12})?$/.test(stripped)) {
                try {
                  return !isNaN(parseFloat(stripped));
                } catch (e) {
                  return false;
                }
              } else {
                return false;
              }
            }
            return null;
          },
          checkValidTokens(t) {
            if (t) {
              const stripped = t.replace(/[,_]/g,"");
              if (/^[+-]?\d{0,18}(\.\d{0,24})?$/.test(stripped)) {
                try {
                  // return !isNaN(ethers.BigNumber.from(stripped));
                  return !isNaN(parseFloat(stripped));
                } catch (e) {
                  return false;
                }
              } else {
                return false;
              }
            }
            return null;
          },
          checkCoinFormValidity() {
            const valid = this.$refs.coinForm.checkValidity()
            if (this.newCoinAddress && this.newCoinAddress.length > 0) {
              try {
                const a = ethers.utils.getAddress(this.newCoinAddress);
                status = a && a.length > 0;
                return status;
              } catch (e) {
                return false;
              }
            } else {
              return valid;
            }
          },
          checkAllowanceFormValidity() {
            const valid = this.$refs.allowanceForm.checkValidity()
            return valid;
          },
          checkWethFormValidity() {
            const valid = this.$refs.wethForm.checkValidity()
            return valid;
          },
          checkAccountFormValidity() {
            const valid = this.$refs.accountForm.checkValidity()
            if (this.newAddress && this.newAddress.length > 0) {
              try {
                const a = ethers.utils.getAddress(this.newAddress);
                status = a && a.length > 0;
                return status;
              } catch (e) {
                return false;
              }
            } else {
              return valid;
            }
          },
          newCoinAddressResetModal() {
            // TODO this.newCoinAddress = null;
            this.newCoinAddress = "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9";
          },
          newCoinAddressHandleOk(bvModalEvent) {
            // Prevent modal from closing
            bvModalEvent.preventDefault();
            // Trigger submit handler
            this.newCoinAddressHandleSubmit();
          },
          async newCoinAddressHandleSubmit() {
            // Exit when the form isn't valid
            if (!this.checkCoinFormValidity()) {
              return;
            }
            if (!(this.newCoinAddress in this.settings.tokens)) {
              console.log("Adding: " + this.newCoinAddress);
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const coinInfo = {
                sync: true,
                include: true,
                latestBlockNumber: null,
              };
              const erc20 = new ethers.Contract(this.newCoinAddress, ERC20ABI, provider);
              try {
                coinInfo.symbol = await erc20.symbol();
              } catch (e) {
                console.log("newCoinAddressHandleSubmit ERROR - symbol - account: " + this.newCoinAddress + ", message: " + e.message);
              }
              try {
                coinInfo.name = await erc20.name();
              } catch (e) {
                console.log("newCoinAddressHandleSubmit ERROR - name - account: " + this.newCoinAddress + ", message: " + e.message);
              }
              try {
                coinInfo.decimals = parseInt(ethers.BigNumber.from(await erc20.decimals()).toString());
              } catch (e) {
                console.log("newCoinAddressHandleSubmit ERROR - decimals - account: " + this.newCoinAddress + ", message: " + e.message);
              }
              try {
                coinInfo.totalSupply = ethers.BigNumber.from(await erc20.totalSupply()).toString();
              } catch (e) {
                console.log("newCoinAddressHandleSubmit ERROR - totalSupply - account: " + this.newCoinAddress + ", message: " + e.message);
              }
              Vue.set(this.settings.tokens, this.newCoinAddress, coinInfo);



              // const erc721Helper = new ethers.Contract(ERC721HELPERADDRESS_SEPOLIA, ERC721HELPERABI, provider);
              // try {
              //   const tokenInfos = await erc721Helper.tokenInfo([this.newCoinAddress], { gasLimit: 1000000 });
              //   console.log("tokenInfos: " + JSON.stringify(tokenInfos, null, 2));
              //   for (let i = 0; i < tokenInfos[0].length; i++) {
              //     coinInfo.mask = tokenInfos[0][i].toNumber();
              //     coinInfo.symbol = tokenInfos[1][i];
              //     coinInfo.name = tokenInfos[2][i];
              //     coinInfo.totalSupply = ethers.BigNumber.from(tokenInfos[3][i]).toString();
              //   }
              // } catch (e) {
              //   console.log("newCoinAddressHandleSubmit ERROR - account: " + this.newCoinAddress + ", message: " + e.message);
              //   coinInfo.mask = 0;
              //   coinInfo.symbol = null;
              //   coinInfo.name = null;
              // }
              // coinInfo.decimals = null;
              // if ((coinInfo.mask & MASK_ISERC20) == MASK_ISERC20) {
              //   const erc20 = new ethers.Contract(this.newCoinAddress, ERC20ABI, provider);
              //   try {
              //     coinInfo.decimals = parseInt(ethers.BigNumber.from(await erc20.decimals()).toString());
              //   } catch (e) {
              //     console.log("newCoinAddressHandleSubmit ERROR - decimals - account: " + this.newCoinAddress + ", message: " + e.message);
              //   }
              //   Vue.set(this.settings.tokens, this.newCoinAddress, { ...coinInfo, mask: undefined });
              // } else {
              //   console.log("Not ERC-20: " + this.newCoinAddress);
              // }
            } else {
              console.log("Discarding duplicate: " + this.newCoinAddress);
            }
            // Hide the modal manually
            this.$nextTick(() => {
              this.$bvModal.hide('new-coin-modal-prevent-closing');
            })
            this.saveSettings();
          },
          async syncCryptoPunksData(section) {

            // v1 v2 event Assign(address indexed to, uint256 punkIndex);
            // v1 v2 event Transfer(address indexed from, address indexed to, uint256 value);
            // v1 v2 event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex);
            // v1 v2 event PunkOffered(uint indexed punkIndex, uint minValue, address indexed toAddress);
            // v1 v2 event PunkBought(uint indexed punkIndex, uint value, address indexed fromAddress, address indexed toAddress);
            // v1 v2 event PunkNoLongerForSale(uint indexed punkIndex);
            //    v2 event PunkBidEntered(uint indexed punkIndex, uint value, address indexed fromAddress);
            //    v2 event PunkBidWithdrawn(uint indexed punkIndex, uint value, address indexed fromAddress);
            // w1 w2 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
            // w1 w2 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
            // w1 w2 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
            // w1 w2 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
            //    w2 event Paused(address account);
            //    w2 event Unpaused(address account);
            //    w2 event ProxyRegistered(address user, address proxy);

            const CONFIRMATIONS = 1000;
            console.log(moment().format("HH:mm:ss") + " syncCryptoPunksData - chainId: " + this.chainId);
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.coinbase = await signer.getAddress();
            localStorage.cryptoPunksDataCoinbase = this.coinbase;
            const network = await provider.getNetwork();
            localStorage.cryptoPunksDataChainId = network.chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " syncCryptoPunksData - latestBlockNumber: " + latestBlockNumber + ", chainId: " + this.chainId);

            console.log("this.indexToEventTypes: " + JSON.stringify(this.indexToEventTypes));
            console.log("this.eventTypesToIndex: " + JSON.stringify(this.eventTypesToIndex));

            let indexToAddress = [];
            let addressToIndex = {};
            const indexToAddressDataItems = await db.cache.where("objectName").equals(this.chainId + "_indexToAddress").toArray();
            if (indexToAddressDataItems.length == 1) {
              indexToAddress = indexToAddressDataItems[0].object;
              // console.log("indexToAddress: " + JSON.stringify(indexToAddress));
            }
            const addressToIndexDataItems = await db.cache.where("objectName").equals(this.chainId + "_addressToIndex").toArray();
            if (addressToIndexDataItems.length == 1) {
              addressToIndex = addressToIndexDataItems[0].object;
              // console.log("addressToIndex: " + JSON.stringify(addressToIndex));
            }
            for (const address of [ADDRESS0, CRYPTOPUNKSV1ADDRESS, CRYPTOPUNKSV2ADDRESS, WRAPPEDCRYPTOPUNKSV1ADDRESS, WRAPPEDCRYPTOPUNKSV2ADDRESS, this.coinbase]) {
              if (!(address in addressToIndex)) {
                addressToIndex[address] = indexToAddress.length;
                indexToAddress.push(address);
              }
            }
            for (const process of this.contracts) {
              console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " Processing: " + process.name);
              // this.sync.section = process.name;
              const contract = new ethers.Contract(process.address, process.abi, provider);
              if (!(process.address in addressToIndex)) {
                addressToIndex[process.address] = indexToAddress.length;
                indexToAddress.push(process.address);
              }
              let events = {};
              let total = 0;
              let newEvents = 0;
              function processLogs(fromBlock, toBlock, logs) {
                total = parseInt(total) + logs.length;
                console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
                for (const event of logs) {
                  if (!event.removed) {
                    const logData = contract.interface.parseLog(event);
                    const txHash = event.transactionHash;
                    const blockNumber = event.blockNumber;
                    const transactionIndex = event.transactionIndex;
                    const logIndex = event.logIndex;
                    const eventType = logData.eventFragment.name;
                    const eventTypeIndex = t.eventTypesToIndex[eventType];
                    // console.log("logData: " + JSON.stringify(logData));
                    // console.log(blockNumber + "." + transactionIndex + " " + eventType);
                    let record = null;

                    if (eventType == "Assign") {
                      const [to, punkIndex] = logData.args;
                      if (!(to in addressToIndex)) {
                        addressToIndex[to] = indexToAddress.length;
                        indexToAddress.push(to);
                      }
                      const toIndex = addressToIndex[to];
                      record = [eventTypeIndex, toIndex, parseInt(punkIndex)];
                    } else if (eventType == "Transfer") {
                      const [from, to, value] = logData.args;
                      for (const address of [from, to]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const fromIndex = addressToIndex[from];
                      const toIndex = addressToIndex[to];
                      record = [ eventTypeIndex, fromIndex, toIndex, parseInt(value) ];
                    } else if (eventType == "PunkTransfer") {
                      const [from, to, punkIndex] = logData.args;
                      for (const address of [from, to]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const fromIndex = addressToIndex[from];
                      const toIndex = addressToIndex[to];
                      record = [ eventTypeIndex, fromIndex, toIndex, parseInt(punkIndex)];
                    } else if (eventType == "PunkOffered") {
                      const [punkIndex, minValue, toAddress] = logData.args;
                      if (!(toAddress in addressToIndex)) {
                        addressToIndex[toAddress] = indexToAddress.length;
                        indexToAddress.push(toAddress);
                      }
                      const toAddressIndex = addressToIndex[toAddress];
                      record = [ eventTypeIndex, parseInt(punkIndex), minValue.toString(), toAddressIndex ];
                    } else if (eventType == "PunkBought") {
                      const [punkIndex, value, fromAddress, toAddress] = logData.args;
                      for (const address of [fromAddress, toAddress]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const fromAddressIndex = addressToIndex[fromAddress];
                      const toAddressIndex = addressToIndex[toAddress];
                      record = [ eventTypeIndex, parseInt(punkIndex), value.toString(), fromAddressIndex, toAddressIndex ];
                    } else if (eventType == "PunkNoLongerForSale") {
                      const [punkIndex] = logData.args;
                      record = [ eventTypeIndex, parseInt(punkIndex) ];
                    } else if (eventType == "PunkBidEntered") {
                      const [punkIndex, value, fromAddress] = logData.args;
                      if (!(fromAddress in addressToIndex)) {
                        addressToIndex[fromAddress] = indexToAddress.length;
                        indexToAddress.push(fromAddress);
                      }
                      const fromAddressIndex = addressToIndex[fromAddress];
                      record = [ eventTypeIndex, parseInt(punkIndex), value.toString(), fromAddressIndex ];
                    } else if (eventType == "PunkBidWithdrawn") {
                      const [punkIndex, value, fromAddress] = logData.args;
                      if (!(fromAddress in addressToIndex)) {
                        addressToIndex[fromAddress] = indexToAddress.length;
                        indexToAddress.push(fromAddress);
                      }
                      const fromAddressIndex = addressToIndex[fromAddress];
                      record = [ eventTypeIndex, parseInt(punkIndex), value.toString(), fromAddressIndex ];
                    } else if (eventType == "OwnershipTransferred") {
                      const [previousOwner, newOwner] = logData.args;
                      for (const address of [previousOwner, newOwner]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const previousOwnerIndex = addressToIndex[previousOwner];
                      const newOwnerIndex = addressToIndex[newOwner];
                      record = [ eventTypeIndex, previousOwnerIndex, newOwnerIndex ];
                    } else if (eventType == "Approval") {
                      const [owner, approved, tokenId] = logData.args;
                      for (const address of [owner, approved]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const ownerIndex = addressToIndex[owner];
                      const approvedIndex = addressToIndex[approved];
                      record = [ eventTypeIndex, ownerIndex, approvedIndex, tokenId.toString() ];
                    } else if (eventType == "ApprovalForAll") {
                      const [owner, operator, approved] = logData.args;
                      for (const address of [owner, operator]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const ownerIndex = addressToIndex[owner];
                      const operatorIndex = addressToIndex[operator];
                      record = [ eventTypeIndex, ownerIndex, operatorIndex, approved ];
                    } else if (eventType == "Paused") {
                      const [account] = logData.args;
                      if (!(account in addressToIndex)) {
                        addressToIndex[account] = indexToAddress.length;
                        indexToAddress.push(fromAddress);
                      }
                      const accountIndex = addressToIndex[account];
                      record = [ eventTypeIndex, accountIndex ];
                    } else if (eventType == "Unpaused") {
                      const [account] = logData.args;
                      if (!(account in addressToIndex)) {
                        addressToIndex[account] = indexToAddress.length;
                        indexToAddress.push(fromAddress);
                      }
                      const accountIndex = addressToIndex[account];
                      record = [ eventTypeIndex, accountIndex ];

                    } else if (eventType == "ProxyRegistered") {
                      const [user, proxy] = logData.args;
                      for (const address of [user, proxy]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const userIndex = addressToIndex[user];
                      const proxyIndex = addressToIndex[proxy];
                      record = [ eventTypeIndex, userIndex, proxyIndex ];

                    } else {
                      console.log("--- UNKNOWN eventType: " + eventType + " ---");
                    }
                    console.log(blockNumber + "." + transactionIndex + " " + JSON.stringify(record));

                    if (record) {
                      // TODO: Add unconfirmed flag
                      const confirmations = latestBlockNumber - blockNumber;
                      // if (!(blockNumber in events)) {
                      //   events[blockNumber] = confirmations < CONFIRMATIONS ? { unconfirmed: true } : {};
                      // }

                      if (!(blockNumber in events)) {
                        // events[blockNumber] = {};
                        events[blockNumber] = confirmations < CONFIRMATIONS ? { unconfirmed: true } : {};
                      }
                      if (!(transactionIndex in events[blockNumber])) {
                        events[blockNumber][transactionIndex] = {};
                      }
                      if (!(txHash in events[blockNumber][transactionIndex])) {
                        events[blockNumber][transactionIndex][txHash] = {};
                      }
                      if (!(logIndex in events[blockNumber][transactionIndex][txHash])) {
                        events[blockNumber][transactionIndex][txHash][logIndex] = record;
                        newEvents++;
                      }
                    }
                  }
                }
              }
              const t = this;
              async function getLogs(fromBlock, toBlock, processLogs, section) {
                if (!t.sync.halt) {
                  try {
                    const filter = { address: process.address, fromBlock, toBlock, topics: [null, null, null] };
                    const eventLogs = await provider.getLogs(filter);
                    processLogs(fromBlock, toBlock, eventLogs);
                    t.sync.section = section;
                    t.sync.completed = toBlock;
                  } catch (e) {
                    const mid = parseInt((fromBlock + toBlock) / 2);
                    await getLogs(fromBlock, mid, processLogs, section);
                    await getLogs(parseInt(mid) + 1, toBlock, processLogs, section);
                  }
                }
              }

              const DEVMODE = false;
              const eventsDataItems = await db.cache.where("objectName").equals(this.chainId + "_" + process.address + "_events").toArray();
              if (eventsDataItems.length == 1) {
                events = eventsDataItems[0].object;
                // console.log("events: " + JSON.stringify(events, null, 2).substring(0, 1000));
                if (!DEVMODE) {
                  Object.keys(events).forEach(function (key) {
                    if ('unconfirmed' in events[key]) {
                      console.log("DELETING: " + key + " => " + JSON.stringify(events[key]));
                      delete events[key];
                    }
                  });
                }
              }
              const blockNumbers = Object.keys(events).sort((a, b) => { return b - a });
              // console.log("blockNumbers: " + JSON.stringify(blockNumbers));
              const startBlock = blockNumbers.length > 0 ? parseInt(blockNumbers[0]) + 1: process.deploymentBlockNumber;
              // console.log("startBlock: " + startBlock);

              this.sync.total = latestBlockNumber;
              this.sync.completed = startBlock;
              if (!DEVMODE) {
                await getLogs(startBlock, latestBlockNumber, processLogs, process.name);
                // console.log("addressToIndex: " + JSON.stringify(addressToIndex, null, 2));
                // console.log("indexToAddress: " + JSON.stringify(indexToAddress, null, 2));
                // console.log("events: " + JSON.stringify(events, null, 2));
                Vue.set(this, "addressToIndex", addressToIndex);
                Vue.set(this, "indexToAddress", indexToAddress);
                await db.cache.put({ objectName: this.chainId + "_indexToAddress", object: indexToAddress }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                await db.cache.put({ objectName: this.chainId + "_addressToIndex", object: addressToIndex }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                await db.cache.put({ objectName: this.chainId + "_" + process.address + "_events", object: events }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }
            }
            this.sync.section = null;
            this.sync.halt = false;

            await this.loadBlockTimestamps();
            await this.loadCurrentData();
          },

          async loadBlockTimestamps(/*context, newBlocks*/) {
            console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " loadBlockTimestamps");
            // this.sync.completed = 0;
            // this.sync.total = newBlocks.length;
            // this.sync.section = context.symbol + ' Timestamps';
            // const BATCHSIZE = 1000;
            // for (let i = 0; i < newBlocks.length; i += BATCHSIZE) {
            //   const batch = newBlocks.slice(i, parseInt(i) + BATCHSIZE);
            //   const data = await fetch(BLOCKTIMESTAMPSUBGRAPHURL, {
            //     method: 'POST',
            //     headers: {
            //       'Content-Type': 'application/json',
            //       'Accept': 'application/json',
            //     },
            //     body: JSON.stringify({
            //       query: BLOCKTIMESTAMPINQUERY,
            //       variables: { blockNumbers: batch.map(e => parseInt(e)) },
            //     })
            //   }).then(response => response.json())
            //     .catch(function(e) {
            //       console.log("error: " + e);
            //     });
            //   const timestamps = data.data && data.data.blocks || [];
            //   for (const timestampItem of timestamps) {
            //     Vue.set(this.blockTimestamps, parseInt(timestampItem.number), parseInt(timestampItem.timestamp));
            //   }
            //   this.sync.completed += timestamps.length;
            //   console.log(moment().format("HH:mm:ss") + " syncBlockTimestamps " + this.sync.completed + " of " + timestamps.length);
            // }
            // await context.db.cache.put({ objectName: "blockTimestamps", object: this.blockTimestamps }).then (function() {
            // }).catch(function(error) {
            //   console.log("error: " + error);
            // });
          },

          // newAccountResetModal() {
          //   this.newAddress = null;
          // },
          // newAccountHandleOk(bvModalEvent) {
          //   // Prevent modal from closing
          //   bvModalEvent.preventDefault();
          //   // Trigger submit handler
          //   this.newAccountHandleSubmit();
          // },
          // newAccountHandleSubmit() {
          //   // Exit when the form isn't valid
          //   if (!this.checkAccountFormValidity()) {
          //     return;
          //   }
          //   if (!(this.newAddress in this.settings.accounts)) {
          //     console.log("Adding: " + this.newAddress);
          //     Vue.set(this.settings.accounts, this.newAddress, {
          //       name: null,
          //       group: null,
          //     });
          //   } else {
          //     console.log("Discarding duplicate: " + this.newAddress);
          //   }
          //   // Hide the modal manually
          //   this.$nextTick(() => {
          //     this.$bvModal.hide('new-account-modal-prevent-closing');
          //   })
          //   this.saveSettings();
          // },

          // allowanceFormResetModal() {
          //   this.allowanceFormData.amount = null;
          // },
          // wethFormResetModal() {
          //   this.wethFormData.direction = "ew";
          //   this.wethFormData.amount = null;
          // },
          // allowanceFormHandleOk(bvModalEvent) {
          //   // Prevent modal from closing
          //   bvModalEvent.preventDefault();
          //   // Trigger submit handler
          //   this.allowanceFormHandleSubmit();
          // },
          // wethFormHandleOk(bvModalEvent) {
          //   // Prevent modal from closing
          //   bvModalEvent.preventDefault();
          //   // Trigger submit handler
          //   this.wethFormHandleSubmit();
          // },
          // async allowanceFormHandleSubmit() {
          //   console.log("allowanceFormHandleSubmit");
          //   // Exit when the form isn't valid
          //   if (!this.checkAllowanceFormValidity()) {
          //     return;
          //   }
          //   const provider = new ethers.providers.Web3Provider(window.ethereum);
          //   const signer = provider.getSigner();
          //   const erc20Contract = new ethers.Contract(this.allowanceFormData.token, ERC20ABI, provider);
          //   const erc20ContractWithSigner = erc20Contract.connect(provider.getSigner());
          //   try {
          //     const tx = await erc20ContractWithSigner.approve(CHADEXADDRESS_SEPOLIA, ethers.utils.parseUnits(this.allowanceFormData.amount, this.allowanceFormData.decimals).toString() );
          //     console.log("tx: " + JSON.stringify(tx));
          //   } catch (e) {
          //     console.log("allowanceFormHandleSubmit error: " + JSON.stringify(e));
          //   }
          //   // Hide the modal manually
          //   this.$nextTick(() => {
          //     this.$bvModal.hide('allowance-modal-prevent-closing');
          //   })
          // },
          // async wethFormHandleSubmit() {
          //   console.log("wethFormHandleSubmit");
          //   // Exit when the form isn't valid
          //   if (!this.checkWethFormValidity()) {
          //     return;
          //   }
          //   const provider = new ethers.providers.Web3Provider(window.ethereum);
          //   const signer = provider.getSigner();
          //   if (this.wethFormData.direction == "ew") {
          //     try {
          //       const tx = await signer.sendTransaction({ to: WETH9ADDRESS_SEPOLIA, value: ethers.utils.parseEther(this.wethFormData.amount) });
          //       console.log("tx: " + JSON.stringify(tx));
          //     } catch (e) {
          //       console.log("wethFormHandleSubmit error: " + JSON.stringify(e));
          //     }
          //   } else {
          //     const wethContract = new ethers.Contract(WETH9ADDRESS_SEPOLIA, WETH9ABI_SEPOLIA, provider);
          //     const wethContractWithSigner = wethContract.connect(provider.getSigner());
          //     try {
          //       const tx = await wethContractWithSigner.withdraw(ethers.utils.parseEther(this.wethFormData.amount));
          //       console.log("tx: " + JSON.stringify(tx));
          //     } catch (e) {
          //       console.log("wethFormHandleSubmit error: " + JSON.stringify(e));
          //     }
          //   }
          //   // Hide the modal manually
          //   this.$nextTick(() => {
          //     this.$bvModal.hide('weth-modal-prevent-closing');
          //   })
          // },

          // toggleAccountField(account, field) {
          //   Vue.set(this.settings.accounts[account], field, !this.settings.accounts[account][field]);
          //   this.saveSettings();
          // },
          // setAccountField(account, field, value) {
          //   Vue.set(this.settings.accounts[account], field, value);
          //   this.saveSettings();
          // },
          // deleteToken(coin) {
          //   Vue.delete(this.settings.tokens, coin);
          //   this.saveSettings();
          // },
          // deleteAccount(account) {
          //   Vue.delete(this.settings.accounts, account);
          //   this.saveSettings();
          // },
          saveSettings() {
            localStorage.cryptoPunksDataSettings = JSON.stringify(this.settings);
            // console.log("saveSettings: " + JSON.stringify(this.settings));
          },
          filterChanged(dataType, option) {
            if (!this.settings.filters[dataType]) {
              Vue.set(this.settings.filters, dataType, {});
            }
            if (this.settings.filters[dataType][option]) {
              Vue.delete(this.settings.filters[dataType], option);
              if (Object.keys(this.settings.filters[dataType]) == 0) {
                Vue.delete(this.settings.filters, dataType);
              }
            } else {
              Vue.set(this.settings.filters[dataType], option, true);
            }
            this.saveSettings();
          },
          resetFilters() {
            Vue.set(this.settings, 'filters', {});
            this.saveSettings();
          },
          // async showModalAccountsImport(item) {
          //   // console.log("showModalAccountsImport: " + JSON.stringify(item));
          //   // let url = "https://api.reservoir.tools/collections/v5?contract=" + item.contract;
          //   // console.log(url);
          //   // const data = await fetch(url).then(response => response.json());
          //   // const collection = data.collections && data.collections.length == 1 && data.collections[0] || {};
          //   this.modalDetails = {
          //     item,
          //     txHash: item[0],
          //   //   token: item,
          //   //   collection,
          //   };
          //   console.log(JSON.stringify(this.modalDetails, null, 2));
          //   this.$bvModal.show('modal-accounts-import');
          // },
          // async showModalTxDetails(item) {
          //   // console.log("showModalTxDetails - item: " + JSON.stringify(item));
          //   const provider = new ethers.providers.Web3Provider(window.ethereum);
          //
          //   // let url = "https://api.reservoir.tools/collections/v5?contract=" + item.contract;
          //   // console.log(url);
          //   // const data = await fetch(url).then(response => response.json());
          //   // const collection = data.collections && data.collections.length == 1 && data.collections[0] || {};
          //   this.modalTxDetails.item = item;
          //   // console.log("showModalTxDetails - this.modalTxDetails.item: " + JSON.stringify(item));
          //   this.$bvModal.show('modal-tx-details');
          //   // this.modalTxDetails = {
          //   //   item,
          //   //   txHash,
          //   // };
          //   const tx = await provider.getTransaction(item.txHash);
          //   // console.log("showModalTxDetails - tx: " + JSON.stringify(tx));
          //   const txReceipt = await provider.getTransactionReceipt(item.txHash);
          //   // console.log("showModalTxDetails - txReceipt: " + JSON.stringify(txReceipt));
          //
          //   if (tx.to == CHADEXADDRESS_SEPOLIA) {
          //     const interface = new ethers.utils.Interface(CHADEXABI);
          //     try {
          //       let decodedData = interface.parseTransaction({ data: tx.data, value: tx.value });
          //       // console.log("showModalTxDetails - decodedData: " + JSON.stringify(decodedData, null, 2));
          //       if (decodedData.functionFragment.name == "execute") {
          //         console.log("showModalTxDetails - execute()");
          //         // const tradeInput = decodedData.functionFragment.inputs;
          //         // console.log("showModalTxDetails - tradeInput: " + JSON.stringify(tradeInput, null, 2));
          //         // console.log("decodedData.functionFragment.inputs: " + JSON.stringify(decodedData.functionFragment.inputs));
          //         // console.log("decodedData.args: " + JSON.stringify(decodedData.args));
          //         // struct TradeInput {
          //         //     Action action;
          //         //     BuySell buySell;
          //         //     Token base;
          //         //     Token quote;
          //         //     Price price;
          //         //     Price targetPrice;
          //         //     Unixtime expiry;
          //         //     Tokens tokens;
          //         //     bool skipCheck;
          //         // }
          //
          //         const tradeInputs = [];
          //         for (let i = 0; i < decodedData.args.length; i++) {
          //           // console.log("decodedData.args[" + i + "]: " + JSON.stringify(decodedData.args[i]));
          //           const details = decodedData.args[i][0];
          //           // console.log("details: " + JSON.stringify(details, null, 2));
          //           const [action, buySell, base, quote, price, targetPrice, expiry, tokens, skipCheck] = decodedData.args[i][0];
          //           // console.log("action: " + action + ", buySell: " + buySell + ", base:" + base + ", quote:" + quote + ", price: " + price + ", targetPrice: " + targetPrice + ", expiry: " + expiry + ", tokens: " + tokens + ", skipCheck: " + skipCheck);
          //           tradeInputs.push({ action, buySell, base, quote, price: price.toString(), targetPrice: targetPrice.toString(), expiry: parseInt(expiry), tokens: tokens.toString(), skipCheck });
          //           // TODO: Testing
          //           // tradeInputs.push({ action, buySell, base, quote, price: price.toString(), targetPrice: targetPrice.toString(), expiry: parseInt(expiry), tokens: tokens.toString(), skipCheck });
          //         }
          //         console.log("tradeInputs: " + JSON.stringify(tradeInputs, null, 2));
          //         Vue.set(this.modalTxDetails, 'tradeInputs', tradeInputs);
          //         for (let i in decodedData.functionFragment.inputs) {
          //           const c = decodedData.functionFragment.inputs[i];
          //           console.log("  " + i + " " + c.name + " " + c.type + " " + JSON.stringify(decodedData.args[i]));
          //         }
          //       }
          //     } catch (e) {
          //       console.log("showModalTxDetails - Error decoding: " + JSON.stringify(tx.data));
          //     }
          //   }
          //
          //   Vue.set(this.modalTxDetails, 'tx', {
          //   //   hash: tx.hash,
          //   //   type: tx.type,
          //   //   blockHash: tx.blockHash,
          //   //   blockNumber: tx.blockNumber,
          //   //   transactionIndex: tx.transactionIndex,
          //     from: tx.from,
          //     to: tx.to,
          //   //   gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
          //   //   gasLimit: ethers.BigNumber.from(tx.gasLimit).toString(),
          //   //   to: tx.to,
          //   //   value: ethers.BigNumber.from(tx.value).toString(),
          //   //   nonce: tx.nonce,
          //   //   data: tx.to && tx.data || null, // Remove contract creation data to reduce memory footprint
          //   //   // r: tx.r,
          //   //   // s: tx.s,
          //   //   // v: tx.v,
          //   //   chainId: tx.chainId,
          //   // });
          //   // const txReceipt = await provider.getTransactionReceipt(txHash);
          //   // Vue.set(this.modalDetails, 'txReceipt', {
          //   //   to: txReceipt.to,
          //   //   from: txReceipt.from,
          //   //   contractAddress: txReceipt.contractAddress,
          //   //   transactionIndex: txReceipt.transactionIndex,
          //   //   gasUsed: ethers.BigNumber.from(txReceipt.gasUsed).toString(),
          //   //   blockHash: txReceipt.blockHash,
          //   //   // transactionHash: txReceipt.transactionHash,
          //   //   logs: txReceipt.logs,
          //   //   blockNumber: txReceipt.blockNumber,
          //   //   // confirmations: txReceipt.confirmations,
          //   //   cumulativeGasUsed: ethers.BigNumber.from(txReceipt.cumulativeGasUsed).toString(),
          //   //   effectiveGasPrice: ethers.BigNumber.from(txReceipt.effectiveGasPrice).toString(),
          //   //   status: txReceipt.status,
          //   //   type: txReceipt.type,
          //   //   // byzantium: txReceipt.byzantium,
          //   });
          //   // console.log("tx: " + JSON.stringify(tx, null, 2));
          //   // console.log("txReceipt: " + JSON.stringify(txReceipt, null, 2));
          //   // console.log(JSON.stringify(this.modalDetails, null, 2));
          // },
          // async showModalTokenDetails(tokenIndex) {
          //   console.log("showModalTokenDetails: " + tokenIndex);
          //   const provider = new ethers.providers.Web3Provider(window.ethereum);
          //   this.$bvModal.show('modal-token-details');
          //   this.modalTokenDetails.tokenIndex = tokenIndex;
          //   const token = this.tokens[tokenIndex] || {};
          //   console.log("this.tokens: " + JSON.stringify(this.tokens, null, 2));
          //   this.modalTokenDetails.address = this.indexToAddress[tokenIndex] || "?";
          //   this.modalTokenDetails.symbol = token.symbol || "?";
          //   this.modalTokenDetails.name = token.name || "?";
          //   this.modalTokenDetails.decimals = token.decimals || "?";
          //   const erc20 = new ethers.Contract(this.modalTokenDetails.address, ERC20ABI, provider);
          //   this.modalTokenDetails.balance = ethers.BigNumber.from(await erc20.balanceOf(this.coinbase)).toString();
          //   this.modalTokenDetails.allowance = ethers.BigNumber.from(await erc20.allowance(this.coinbase, CHADEXADDRESS_SEPOLIA)).toString();
          //   this.modalTokenDetails.totalSupply = ethers.BigNumber.from(await erc20.totalSupply()).toString() || "?";
          //   console.log("balance: " + this.modalTokenDetails.balance);
          // },
          // async showModalMakerOrder(buySell, item) {
          //   console.log("showModalMakerOrder - buySell: " + buySell + ", item: " + JSON.stringify(item));
          //   const provider = new ethers.providers.Web3Provider(window.ethereum);
          //   this.$bvModal.show('modal-maker-order');
          //   this.modalMakerOrder.pairKey = this.settings.pairTable.selectedPair;
          //   this.modalMakerOrder.buySell = buySell;
          //   this.modalMakerOrder.price = item.price;
          //   this.modalMakerOrder.orderKey = item.orderKey;
          //   this.modalMakerOrder.makerIndex = item.makerIndex;
          //   this.modalMakerOrder.expiry = item.expiry;
          //   this.modalMakerOrder.originalTokens = item.originalTokens;
          //   this.modalMakerOrder.tokens = item.tokens;
          //   this.modalMakerOrder.availableBase = item.availableBase;
          //   this.modalMakerOrder.availableQuote = item.availableQuote;
          //   console.log("this.modalMakerOrder: " + JSON.stringify(this.modalMakerOrder, null, 2));
          // },
          // toggleSyncAccounts(items) {
          //   let someFalse = false;
          //   let someTrue = false;
          //   for (const item of items) {
          //     if (item.sync) {
          //       someTrue = true;
          //     } else {
          //       someFalse = true;
          //     }
          //   }
          //   for (const item of items) {
          //     Vue.set(this.settings.accounts[item.address], 'sync', !(someTrue && !someFalse));
          //   }
          //   this.saveSettings();
          // },
          // toggleIncludeAccounts(items) {
          //   let someFalse = false;
          //   let someTrue = false;
          //   for (const item of items) {
          //     if (item.include) {
          //       someTrue = true;
          //     } else {
          //       someFalse = true;
          //     }
          //   }
          //   for (const item of items) {
          //     Vue.set(this.settings.accounts[item.address], 'include', !(someTrue && !someFalse));
          //   }
          //   this.saveSettings();
          // },
          async syncAll(blockNumber) {
            console.log(moment().format("HH:mm:ss") + " syncAll - blockNumber: " + blockNumber + ", chainId: " + this.chainId);
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            // console.log("latestBlockNumber: " + latestBlockNumber);
            // const CONFIRMATIONS = 10;
            // const confirmedBlockNumber = block && block.number && (block.number - CONFIRMATIONS) || null;
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const context = { provider, latestBlockNumber, db };
            if (this.chainId == CHAINID_SEPOLIA) {
              await this.syncChadexEvents(context);
              await this.syncChadexPairs(context);
              await this.syncChadexPair(context);
            }
            // if (this.chainId == CHAINID_MAINNET) {
              // console.log("CHAINID_MAINNET: TODO");
              // await this.syncAllENSNames(context);
            // }
            // for (const [address, coinInfo] of Object.entries(this.settings.tokens)) {
            //   if (coinInfo.sync && !this.sync.halt) {
            //     const context = { provider, confirmedBlockNumber, db, address, symbol: coinInfo.symbol };
            //     // await this.syncCoinTransfers(context);
            //     // await this.syncUniswapV2Pools(context);
            //     // await this.syncUniswapV3Pools(context);
            //     // await this.syncUniswapV2Trades(context);
            //     // await this.syncUniswapV3Trades(context);
            //     // await this.syncUniswapAltTokenTransfers(context);
            //     // // await this.syncAllENSNames(context);
            //     // // await this.testSyncENSNames(context);
            //   }
            // }
            // this.sync.section = null;
            // this.sync.halt = false;
            db.close();
            // await this.loadCurrentData(); // TODO
          },
          // async syncBlockTimestamps(context, newBlocks) {
          //   this.sync.completed = 0;
          //   this.sync.total = newBlocks.length;
          //   this.sync.section = context.symbol + ' Timestamps';
          //   const BATCHSIZE = 1000;
          //   for (let i = 0; i < newBlocks.length; i += BATCHSIZE) {
          //     const batch = newBlocks.slice(i, parseInt(i) + BATCHSIZE);
          //     const data = await fetch(BLOCKTIMESTAMPSUBGRAPHURL, {
          //       method: 'POST',
          //       headers: {
          //         'Content-Type': 'application/json',
          //         'Accept': 'application/json',
          //       },
          //       body: JSON.stringify({
          //         query: BLOCKTIMESTAMPINQUERY,
          //         variables: { blockNumbers: batch.map(e => parseInt(e)) },
          //       })
          //     }).then(response => response.json())
          //       .catch(function(e) {
          //         console.log("error: " + e);
          //       });
          //     const timestamps = data.data && data.data.blocks || [];
          //     for (const timestampItem of timestamps) {
          //       Vue.set(this.blockTimestamps, parseInt(timestampItem.number), parseInt(timestampItem.timestamp));
          //     }
          //     this.sync.completed += timestamps.length;
          //     console.log(moment().format("HH:mm:ss") + " syncBlockTimestamps " + this.sync.completed + " of " + timestamps.length);
          //   }
          //   await context.db.cache.put({ objectName: "blockTimestamps", object: this.blockTimestamps }).then (function() {
          //   }).catch(function(error) {
          //     console.log("error: " + error);
          //   });
          // },
          // async testSyncENSNames(context) {
          //   await this.syncENSNames(context, this.indexToAddress);
          // },
          async syncAllENSNames(context) {
            console.log("syncAllENSNames");
            const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, context.provider);

            let indexToAddress = [];
            let addressToIndex = {};
            const indexToAddressDataItems = await context.db.cache.where("objectName").equals(CHAINID_SEPOLIA + "_indexToAddress").toArray();
            if (indexToAddressDataItems.length == 1) {
              indexToAddress = indexToAddressDataItems[0].object;
              console.log("indexToAddress: " + JSON.stringify(indexToAddress));
            }
            const addressToIndexDataItems = await context.db.cache.where("objectName").equals(CHAINID_SEPOLIA + "_addressToIndex").toArray();
            if (addressToIndexDataItems.length == 1) {
              addressToIndex = addressToIndexDataItems[0].object;
              console.log("addressToIndex: " + JSON.stringify(addressToIndex));
            }

            const addresses = indexToAddress;
            // addresses.sort();
          //
            const MAXBATCHSIZE = 1000;
            let batchSize = MAXBATCHSIZE;
            let completed = 0;
            let done = false;
            let start = completed;
            do {
              let end = parseInt(start) + batchSize - 1;
              if (end > addresses.length) {
                end = addresses.length;
              }
              try {
                const batch = addresses.slice(start, end + 1);
                // console.log("batch: " + JSON.stringify(batch, null, 2));
                const allnames = await ensReverseRecordsContract.getNames(batch);
                // console.log("allnames: " + JSON.stringify(allnames, null, 2));
                // console.log(start + " - " + end + " " + batch.length);
                for (let j = 0; j < batch.length; j++) {
                  const account = batch[j];
                  const name = allnames[j];
                  // const normalized = normalize(account);
                  if (name.length > 0) {
                    // console.log(account + " => " + name);
                    Vue.set(this.indexToName, addressToIndex[account], name);
                  }
                }
                start = parseInt(end) + 1;
              } catch (e) {
                if (batchSize > 1) {
                  batchSize = parseInt(batchSize / 2);
                } else {
                  console.log("Skipping #" + start + " " + addresses[start]);
                  start = parseInt(start) + 1;
                  batchSize = MAXBATCHSIZE;
                }
              }
              done = start > indexToAddress.length;
            } while (!done);
            // console.log("this.indexToName: " + JSON.stringify(this.indexToName, null, 2));
            await context.db.cache.put({ objectName: CHAINID_MAINNET + "_indexToName", object: this.indexToName }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
          },
          async syncENSNames(context, newAccounts) {
            this.sync.completed = 0;
            this.sync.total = newAccounts.length;
            this.sync.section = context.symbol + ' ENS';
            const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, context.provider);

            const MAXBATCHSIZE = 1000;
            let batchSize = MAXBATCHSIZE;
            let completed = 0;
            let start = completed;
            do {
              let end = parseInt(start) + batchSize - 1;
              if (end > newAccounts.length) {
                end = newAccounts.length;
              }
              try {
                const batch = newAccounts.slice(start, end + 1);
                const allnames = await ensReverseRecordsContract.getNames(batch);
                for (let j = 0; j < batch.length; j++) {
                  const account = batch[j];
                  const name = allnames[j];
                  // const normalized = normalize(account);
                  if (name.length > 0) {
                    // console.log(account + " => " + name);
                    Vue.set(this.indexToName, this.addressToIndex[account], name);
                  }
                }
                this.sync.completed += batch.length;
                console.log(moment().format("HH:mm:ss") + " syncENSNames " + this.sync.completed + " of " + newAccounts.length);
                start = parseInt(end) + 1;
              } catch (e) {
                if (batchSize > 1) {
                  batchSize = parseInt(batchSize / 2);
                } else {
                  console.log("Skipping #" + start + " " + newAccounts[start]);
                  start = parseInt(start) + 1;
                  batchSize = MAXBATCHSIZE;
                }
              }
            } while (start <= newAccounts.length);


            //
            //
            // const BATCHSIZE = 5;
            // for (let i = 0; i < newAccounts.length; i += BATCHSIZE) {
            //   const batch = newAccounts.slice(i, parseInt(i) + BATCHSIZE);
            //   console.log("batch: " + batch);
            //   try {
            //     const allnames = await ensReverseRecordsContract.getNames(batch);
            //     console.log("allnames: " + allnames);
            //     for (let j = 0; j < batch.length; j++) {
            //       const account = batch[j];
            //       const name = allnames[j];
            //       // const normalized = normalize(account);
            //       // console.log(account + " => " + name);
            //       Vue.set(this.indexToName, account, name);
            //     }
            //     this.sync.completed += batch.length;
            //   } catch (e) {
            //     console.log("ENS getNames: " + e);
            //   }
            // }
            await context.db.cache.put({ objectName: "indexToName", object: this.indexToName }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
          },

          async loadCurrentData() {
            console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " loadCurrentData BEGIN");
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const indexToAddressDataItems = await db.cache.where("objectName").equals(this.chainId + "_indexToAddress").toArray();
            if (indexToAddressDataItems.length == 1) {
              Vue.set(this, 'indexToAddress', indexToAddressDataItems[0].object);
              // console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " " + "loadCurrentData - indexToAddress: " + JSON.stringify(this.indexToAddress.slice(0, 3)) + ", ...");
            }
            const addressToIndexDataItems = await db.cache.where("objectName").equals(this.chainId + "_addressToIndex").toArray();
            if (addressToIndexDataItems.length == 1) {
              Vue.set(this, 'addressToIndex', addressToIndexDataItems[0].object);
              // console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " " + "loadCurrentData - addressToIndex: " + JSON.stringify(Object.entries(this.addressToIndex).slice(0, 3)) + ", ...");
            }

            let count = 0;
            const txs = {};
            for (const process of this.contracts) {
              // console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " loadCurrentData - processing: " + process.name);
              const contractIndex = this.addressToIndex[process.address];

              const eventsDataItems = await db.cache.where("objectName").equals(this.chainId + "_" + process.address + "_events").toArray();
              if (eventsDataItems.length == 1) {
                events = eventsDataItems[0].object;
                // console.log("events: " + JSON.stringify(events, null, 2).substring(0, 1000));
                // Object.keys(events).forEach(function (key) {
                //   if ('unconfirmed' in events[key]) {
                //     console.log("DELETING: " + key + " => " + JSON.stringify(events[key]));
                //     delete events[key];
                //   }
                // });
                for (const [blockNumber, txIndexes] of Object.entries(events)) {
                  for (const [txIndex, txHashes] of Object.entries(txIndexes)) {
                    for (const [txHash, logIndexes] of Object.entries(txHashes)) {
                      if (!(txHash in txs)) {
                        txs[txHash] = [ parseInt(blockNumber), parseInt(txIndex), [] ];
                      }
                      for (const [logIndex, txInfo] of Object.entries(logIndexes)) {
                        txs[txHash][2].push([ parseInt(logIndex), contractIndex, ...txInfo ]);
                        // if ((count % 10000) == 0) {
                        //   console.log(count + " " + blockNumber + "/" + txIndex + "/" + txHash + "/" + logIndex + " => " + JSON.stringify(txInfo));
                        // }
                        // count++
                      }
                    }
                  }
                }

              }

            }
            // console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " txs: " + JSON.stringify(txs));
            this.txs = txs;
            // console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " this.txs: " + JSON.stringify(new Map(Array.from(this.txs).slice(0, 9))));
            // console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " this.txs: " +  JSON.stringify(this.txs).substring(0, 1000));
            console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " Unique txHashes: " + Object.keys(this.txs).length);

            console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " loadCurrentData END");
          },

          async halt() {
            this.sync.halt = true;
            console.log("this.sync.halt: " + this.sync.halt);
          },
          commify(n) {
            if (n != null) {
              return ethers.utils.commify(n);
            }
            return null;
          },
          sanitise(str, length = 32) {
            let result = str && str.replace(/[^a-z0-9 \.,_-ðŸ’ª]/gim,"_").trim() || "(null)";
            if (result && length > 0) {
              result = result.substring(0, length);
            }
            return result;
          },
          formatETH(e) {
            try {
              return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(9) : null;
            } catch (err) {
            }
            return e.toFixed(9);
          },
          formatERC20(e, decimals = 18) {
            try {
              return e ? ethers.utils.formatUnits(e, decimals) : null;
            } catch (err) {
            }
            return e.toString();
          },
          formatRate(e, decimals = 18, fixed = 10) {
            try {
              return e ? parseFloat(ethers.utils.formatUnits(e, decimals)).toFixed(fixed) : null;
            } catch (err) {
            }
            return e.toString();
          },
          formatTimestamp(ts) {
            if (ts != null) {
              return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
            }
            return null;
          },
          formatExpiryShort(unixtime) {
            if (!unixtime) {
              return "no expiry";
            } else {
              if (unixtime > moment().unix()) {
                return moment.unix(unixtime).fromNow();
              } else {
                return "expired";
              }
            }
          },
          formatExpiry(unixtime) {
            if (!unixtime) {
              return "no expiry";
            } else {
              return moment.unix(unixtime).format("YYYY-MM-DD HH:mm:ss");
            }
          },
          formatTimeDiff(unixtime) {
            if (!unixtime) {
              return "";
            } else {
              return moment.unix(unixtime).fromNow();
            }
          },
          ensOrAddress(addressOrAddressIndex, length = 0) {
            let result = null;
            if (new RegExp('^[0-9,]+$').test(addressOrAddressIndex)) {
              result = this.indexToName[addressOrAddressIndex];
            } else {
              result = this.indexToName[this.addressToIndex[addressOrAddressIndex]] || addressOrAddressIndex;
            }
            if (result && length > 0) {
              result = result.substring(0, length);
            }
            return result;
          },
          exportTxHashes() {
            console.log("exportTxHashes");
            var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.txHashes));
            var link = document.createElement("a");
            link.setAttribute("href", dataStr);
            link.setAttribute("download", "txhashes.json");
            document.body.appendChild(link); // Required for FF
            link.click();
          },
          exportAccounts() {
            console.log("exportAccounts");
            const rows = [
                ["No", "Address", "Name", "ENSName", "Group", "Sync", "Include"],
            ];
            let i = 1;
            for (const result of this.filteredSortedAccounts) {
              rows.push([
                i,
                result.address,
                result.name,
                result.ensName,
                result.group,
                result.sync ? "y" : "n",
                result.include ? "y" : "n",
              ]);
              i++;
            }
            let tsvContent = "data:text/tsv;charset=utf-8," + rows.map(e => e.join("\t")).join("\n");
            var encodedUri = encodeURI(tsvContent);
            var link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "mynfts_account_export-" + moment().format("YYYY-MM-DD-HH-mm-ss") + ".tsv");
            document.body.appendChild(link); // Required for FF
            link.click(); // This will download the data with the specified file name
          },
          async backupFilesChange(fileName, fileList) {
            const reader = new FileReader();
            this.restoreAddresses = [];
            const t = this;
            reader.onload = function (event) {
              const data = event.target.result;
              const lines = data.split("\n");
              for (const line of lines) {
                const fields = line.split("\t");
                // console.log(JSON.stringify(fields));
                if (fields[0] != "No") {
                  const [number, address, name, ensName, group, sync, include]  = fields;
                  t.restoreAddresses.push({ address, name, ensName, group, sync, include });
                }
              }
            };
            await reader.readAsText(fileList[0]);
          },
          restoreFromBackup() {
            if (this.restoreAddresses) {
              for (const addressData of this.restoreAddresses) {
                if (!(addressData.address in this.settings.accounts)) {
                  console.log("Adding: " + JSON.stringify(addressData));
                  Vue.set(this.settings.accounts, addressData.address, {
                    name: addressData.name,
                    ensName: null,
                    group: addressData.group,
                    sync: true,
                    include: true,
                  });
                } else {
                  console.log("Discarding duplicate: " + JSON.stringify(addressData));
                }
              }
              this.saveSettings();
            }
          },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
            // Below does not work when copying from modal dialog window
            // // https://github.com/30-seconds/30-seconds-of-code/blob/master/snippets/copyToClipboard.md
            // const el = document.createElement('textarea');
            // el.value = str;
            // el.setAttribute('readonly', '');
            // el.style.position = 'absolute';
            // el.style.left = '-9999px';
            // document.body.appendChild(el);
            // const selected =
            //   document.getSelection().rangeCount > 0
            //     ? document.getSelection().getRangeAt(0)
            //     : false;
            // el.select();
            // document.execCommand('copy');
            // document.body.removeChild(el);
            // if (selected) {
            //   document.getSelection().removeAllRanges();
            //   document.getSelection().addRange(selected);
            // }
          },
          async connectToWeb3() {
            console.log(moment().format("HH:mm:ss") + " connectToWeb3");
            if (!window.ethereum) {
              this.connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                this.connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                this.connected = false;
              }
            }
            // console.log(moment().format("HH:mm:ss") + " connectToWeb3 - connected: " + this.connected);
            if (!this.connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const t = this;
              // console.log(moment().format("HH:mm:ss") + " connectToWeb3 - installing listeners");
              function handleChainChanged(_chainId) {
                t.chainId = _chainId;
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
                alert('Ethereum chain has changed - reloading this page.')
                window.location.reload();
              }
              window.ethereum.on('chainChanged', handleChainChanged);
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              async function handleAccountsChanged(accounts) {
                const signer = provider.getSigner();
                t.coinbase = await signer.getAddress();
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
              }
              window.ethereum.on('accountsChanged', handleAccountsChanged);
              async function handleNewBlock(blockNumber) {
                // console.log(moment().format("HH:mm:ss") + " handleNewBlock - New Block #" + blockNumber);
                const block = await provider.getBlock();
                t.blockNumber = blockNumber;
                t.timestamp = block.timestamp;
                await t.syncAll(blockNumber);
              }
              provider.on("block", handleNewBlock);
              const signer = provider.getSigner();
              this.coinbase = await signer.getAddress();
              const network = await provider.getNetwork();
              this.chainId = network.chainId;
              console.log(moment().format("HH:mm:ss") + " connectToWeb3 - this.chainId: " + this.chainId);
            }
          },
          // TODO: Delete
          async processIt(action, parameters = null) {
            console.log("processIt - action: " + action + ", parameters: " + parameters);
            let connected = true;
            if (!window.ethereum) {
              connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                connected = false;
              }
            }
            if (!connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
              const erc721Helper = new ethers.Contract(ERC721HELPERADDRESS_SEPOLIA, ERC721HELPERABI, provider);
              this.coinbase = await signer.getAddress();
              localStorage.cryptoPunksDataCoinbase = this.coinbase;
              const network = await provider.getNetwork();
              console.log("network: " + JSON.stringify(network));
              localStorage.cryptoPunksDataChainId = network.chainId;
              this.chainId = network.chainId;
              const block = await provider.getBlock("latest");
              const blockNumber = block.number;
              const timestamp = block.timestamp;

              provider.off("block");
              // provider.removeAllListeners("block");
              provider.on("block", async (n) => {
                console.log(moment().format("YYYY-MM-DD HH:mm:ss") + " " + JSON.stringify(n));
              });
              const listenerCount = provider.listenerCount("block");
              console.log("listenerCount: " + listenerCount);

              const ENSOWNERBATCHSIZE = 100; // 500 fails occassionally

              const db = new Dexie(this.db.name);
              db.version(this.db.version).stores(this.db.schemaDefinition);

              if (action == "retrieveMainCollection") {
                console.log("retrieveMainCollection");
                let continuation = null;
                this.sync.completed = 0;
                this.sync.total = null;
                this.sync.section = "Main collection";
                const mainTokens = {};
                this.mainToken.collection.name = null;
                do {
                  let url = "https://api.reservoir.tools/tokens/v5?contract=" + this.settings.mainCollection + "&limit=100" +
                    (continuation != null ? "&continuation=" + continuation : '');
                  console.log("url: " + url);
                  const data = await fetch(url)
                    .then(handleErrors)
                    .then(response => response.json())
                    .catch(function(error) {
                       console.log("ERROR - updateCollection: " + error);
                       // state.sync.error = true;
                       return [];
                    });
                  continuation = data.continuation;
                  if (data && data.tokens) {
                    for (const tokenData of data.tokens) {
                      const token = tokenData.token;
                      mainTokens[token.tokenId] = {
                        owner: token.owner,
                        image: token.image,
                      };
                      if (this.mainToken.collection.name == null) {
                        this.mainToken.collection.name = token.collection.name;
                        this.mainToken.collection.image = token.collection.image;
                        this.mainToken.collection.slug = token.collection.slug;
                      }
                    }
                  }
                  this.sync.completed = Object.keys(mainTokens).length;
                  await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                } while (continuation != null /*&& !this.sync.halt && !state.sync.error */);

                const mainOwners = {};
                for (const [tokenId, data] of Object.entries(mainTokens)) {
                  if (!(data.owner in mainOwners)) {
                    mainOwners[data.owner] = [];
                  }
                  mainOwners[data.owner].push(tokenId);
                }

                this.sync.completed = 0;
                const addresses = Object.keys(mainOwners);
                this.sync.total = addresses.length;
                this.sync.section = "ENS Names";
                const indexToName = {};
                for (let i = 0; i < addresses.length & !this.sync.halt; i += ENSOWNERBATCHSIZE) {
                  const batch = addresses.slice(i, parseInt(i) + ENSOWNERBATCHSIZE);
                  const allnames = await ensReverseRecordsContract.getNames(batch);
                  for (let j = 0; j < batch.length; j++) {
                    const address = batch[j];
                    const name = allnames[j];
                    indexToName[address] = name != null && name.length > 0 ? name : address;
                    // const normalized = normalize(address);
                  }
                  this.sync.completed = parseInt(this.sync.completed) + batch.length;
                }
                this.indexToName = indexToName;
                await db.cache.put({ objectName: 'indexToName', object: indexToName }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.mainToken.tokens = mainTokens;
                this.mainToken.owners = mainOwners;
                await db.cache.put({ objectName: 'mainToken', object: this.mainToken }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.secondaryData = {};
                await db.cache.put({ objectName: 'secondaryData', object: this.secondaryData }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.sync.section = null;
              }

              if (action == "syncCollections") {
                console.log("syncCollections");
                let contracts = [];
                if (Object.keys(this.selectedCollections).length > 0) {
                  contracts = Object.keys(this.selectedCollections);
                } else {
                  for (const record of this.filteredSortedCollections) {
                    if (!(record.contract in this.secondaryData)) {
                      contracts.push(record.contract);
                    }
                  }
                }
                console.log("contracts: " + JSON.stringify(contracts));
                for (let contract of contracts) {
                  console.log("Processing: " + contract + " " + JSON.stringify(this.collections[contract]));

                  let continuation = null;
                  this.sync.completed = 0;
                  this.sync.total = null;
                  this.sync.section = this.collections[contract].name.substring(0, 24);
                  const tokens = {};
                  do {
                    let url = "https://api.reservoir.tools/tokens/v5?contract=" + contract + "&includeAttributes=false&limit=100" +
                      (continuation != null ? "&continuation=" + continuation : '');
                    console.log("url: " + url);
                    const data = await fetch(url)
                      .then(handleErrors)
                      .then(response => response.json())
                      .catch(function(error) {
                         console.log("ERROR - updateCollection: " + error);
                         // state.sync.error = true;
                         return [];
                      });
                    continuation = data.continuation;
                    if (data && data.tokens) {
                      for (const tokenData of data.tokens) {
                        const token = tokenData.token;
                        tokens[token.tokenId] = {
                          owner: token.owner,
                          image: token.image,
                        };
                      }
                    }
                    this.sync.completed = Object.keys(tokens).length;
                    await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  } while (continuation != null /*&& !this.sync.halt && !state.sync.error */);
                  Vue.set(this.collections[contract], 'tokens', tokens);
                  const owners = {};
                  for (const [tokenId, data] of Object.entries(tokens)) {
                    if (!(data.owner in owners)) {
                      owners[data.owner] = [];
                    }
                    owners[data.owner].push(tokenId);
                  }
                  Vue.set(this.collections[contract], 'owners', owners);
                  Vue.set(this.collections[contract], 'updated', timestamp);
                  Vue.set(this.collections[contract], 'blockNumber', blockNumber);
                }
                await db.cache.put({ objectName: 'collections', object: this.collections }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              if (action == "retrieveSecondaryCollection") {
                console.log("retrieveSecondaryCollection");
                let owners = [];
                if (Object.keys(this.selectedMainTable).length > 0) {
                  owners = Object.keys(this.selectedMainTable);
                } else {
                  for (const record of this.filteredSortedMainTable) {
                    if (!(record.owner in this.secondaryData)) {
                      owners.push(record.owner);
                    }
                  }
                }
                console.log("owners: " + JSON.stringify(owners));

                this.sync.completed = 0;
                this.sync.total = owners.count;
                this.sync.section = "Secondary collection";
                for (let owner of owners) {
                  console.log("Processing: " + owner);
                  Vue.set(this.secondaryData, owner, {});
                  let stop = false;
                  const LIMIT = 100;
                  const MAXLIMIT = 10000;
                  for (let offset = 0; offset < MAXLIMIT && !stop; offset = parseInt(offset) + LIMIT) {
                    let url = "https://api.reservoir.tools/users/" + owner + "/tokens/v5?sortBy=acquiredAt&sortDirection=desc&offset=" + offset + "&limit=" + LIMIT + "&includeTopBid=false";
                    console.log("url: " + url);
                    const data = await fetch(url)
                      .then(handleErrors)
                      .then(response => response.json())
                      .catch(function(error) {
                         console.log("ERROR - updateCollection: " + error);
                         // state.sync.error = true;
                         return [];
                      });
                    if (data && data.tokens && data.tokens.length > 0) {
                      for (const tokenData of data.tokens) {
                        const contract = tokenData.token.contract;
                        const tokenId = tokenData.token.tokenId;
                        const name = tokenData.token.name;
                        const image = tokenData.token.image;
                        const collectionName = tokenData.token.collection.name;
                        const collectionImage = tokenData.token.collection.imageUrl;
                        if (!(contract in this.secondaryData[owner])) {
                          Vue.set(this.secondaryData[owner], contract, {
                            collectionName,
                            collectionImage,
                            tokens: {},
                          });
                        }
                        Vue.set(this.secondaryData[owner][contract].tokens, tokenId, { tokenId, name, image });
                      }
                    } else {
                      stop = true;
                    }
                    await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  }
                  await delay(1000); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  this.sync.completed = parseInt(this.sync.completed) + 1;
                  if (this.sync.halt) {
                    break;
                  }
                }
                await db.cache.put({ objectName: 'secondaryData', object: this.secondaryData }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              db.close();
              this.sync.section = null;
              this.sync.halt = false;
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          // if ('chadexConnectV1' in localStorage) {
          //   this.connect = localStorage.chadexConnectV1;;
          // }
          (async() => {
            await this.connectToWeb3();
          })();

          if ('cryptoPunksDataChainId' in localStorage) {
            this.chainId = localStorage.cryptoPunksDataChainId;
            console.log("mounted - this.chainId: " + this.chainId);
          }
          if ('cryptoPunksDataCoinbase' in localStorage) {
            this.coinbase = localStorage.cryptoPunksDataCoinbase;
            console.log("mounted - this.coinbase: " + this.coinbase);
          }
          // if ('chadexPairsV1' in localStorage) {
          //   this.pairs = JSON.parse(localStorage.chadexPairsV1);
          // }
          // if ('chadexPairV1' in localStorage) {
          //   this.pair = JSON.parse(localStorage.chadexPairV1);
          //   // console.log("this.pair: " + JSON.stringify(this.pair, null, 2));
          // }
          if ('cryptoPunksDataSettings' in localStorage) {
            const tempSettings = JSON.parse(localStorage.cryptoPunksDataSettings);
            if ('version' in tempSettings && tempSettings.version == this.settings.version) {
              this.settings = tempSettings;
              if (this.settings.punksTable.currentPage > 1) {
                this.settings.punksTable.currentPage = 1;
              }
              if (this.settings.activityTable.currentPage > 1) {
                this.settings.activityTable.currentPage = 1;
              }
            }
          }
          (async() => {
            // console.log("mounted - Before connectToWeb3");
            // await this.connectToWeb3();
            // console.log("mounted - After connectToWeb3");
            //
            const db0 = new Dexie(this.db.name);
            db0.version(this.db.version).stores(this.db.schemaDefinition);
            const blockTimestampsDataItems = await db0.cache.where("objectName").equals('blockTimestamps').toArray();
            if (blockTimestampsDataItems.length == 1) {
              this.blockTimestamps = blockTimestampsDataItems[0].object;
            }

            // const indexToAddressDataItems = await db0.cache.where("objectName").equals(this.chainId + "_indexToAddress").toArray();
            // if (indexToAddressDataItems.length == 1) {
            //   this.indexToAddress = indexToAddressDataItems[0].object;
            //   console.log("indexToAddress: " + JSON.stringify(this.indexToAddress));
            // }
            // const addressToIndexDataItems = await db0.cache.where("objectName").equals(this.chainId + "_addressToIndex").toArray();
            // if (addressToIndexDataItems.length == 1) {
            //   this.addressToIndex = addressToIndexDataItems[0].object;
            //   console.log("addressToIndex: " + JSON.stringify(this.addressToIndex));
            // }

            // const indexToNameDataItems = await db0.cache.where("objectName").equals(CHAINID_MAINNET + "_indexToName").toArray();
            // if (indexToNameDataItems.length == 1) {
            //   this.indexToName = indexToNameDataItems[0].object;
            //   console.log("mounted - indexToName: " + JSON.stringify(this.indexToName));
            // }

            // db0.close();
            await this.loadCurrentData();
          })();
        },
      })
    </script>
  </body>
</html>
