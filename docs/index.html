<!DOCTYPE html>
<html lang="en">
  <head>
    <title>CryptoPunksData</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="CryptoPunksData (c) Bok Consulting Pty Ltd 2023" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="globals.js"></script>
    <script src="deploymentData.js"></script>
    <script src="punkAttributes.js"></script>
    <script src="parsePunkTx.js"></script>
    <script src="txparser.js"></script>

    <link rel="apple-touch-icon" sizes="57x57" href="/images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/images/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/punk_3636.png" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">CryptoPunksData</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings()" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Welcome screen with info'">Home</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings()" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'View Activity'">Activity</b-nav-item>
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings()" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'View/sync Pair'">Pair</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 3; saveSettings()" :active="settings.tabIndex == 3" active-class="active" v-b-popover.hover="'View/edit ERC-20 tokens'">Tokens</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 4; saveSettings()" :active="settings.tabIndex == 4" active-class="active" v-b-popover.hover="'Execute raw Chadex transactions'">Raw</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 5; saveSettings()" :active="settings.tabIndex == 5" active-class="active" v-b-popover.hover="'View info'">Info</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 5; saveSettings()" :active="settings.tabIndex == 5" active-class="active" v-b-popover.hover="'View/edit my accounts'">Accounts</b-nav-item> -->
            <b-avatar v-if="coinbase && coinbase != ensOrAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensOrAddress(coinbase)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar>
            <b-button size="sm" variant="outline-primary" class="ml-1" @click="processIt('connect'); syncAll();" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? ensOrAddress(coinbase, 16) : 'Connect' }}</b-button>
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Revoke permissions when not required, at this early stage.
          </b-alert>
          <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase || chainId != '1'">
            <b-card-text>
              Please install the MetaMask extension, connect to the Ethereum Mainnet and refresh this page. Then click the [Connect] button on the top right.
            </b-card-text>
          </b-card>

          <b-modal id="modal-tx-details" hide-footer size="lg">
            <template #modal-title>
              <font size="-1">Tx {{ modalTxDetails.item.txHash }}</font>
              <b-button size="sm" @click="copyToClipboard(modalTxDetails.item.txHash);" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Copy to clipboard'"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
              <b-link size="sm" :href="'https://sepolia.etherscan.io/tx/' + modalTxDetails.item.txHash" target="_blank" variant="link" class="m-0 p-0" v-b-popover.hover.top="'View in etherscan.io'">
                <b-img rounded="0" width="16px" height="16px" src="images/etherscan-logo-circle.svg" blank-color="#777" target="_blank"></b-img>
              </b-link>
            </template>
            <b-form-group v-if="modalTxDetails.item" label="Block Number:" label-for="modal-tx-details-blocknumber" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-tx-details-blocknumber" :value="modalTxDetails.item.blockNumber" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group v-if="modalTxDetails.item" label="Timestamp:" label-for="modal-tx-details-timestamp" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" readonly size="sm" id="modal-tx-details-timestamp" :value="formatTimestamp(modalTxDetails.item.timestamp)" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group v-if="modalTxDetails.tx" label="From:" label-for="modal-tx-details-from" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <template slot="description">
                <div v-if="ensOrAddress(modalTxDetails.tx.from) != modalTxDetails.tx.from">
                  {{ modalTxDetails.tx.from }}
                </div>
              </template>
              <b-input-group size="sm" class="w-75">
                <b-form-input type="text" readonly size="sm" id="modal-tx-details-from" :value="ensOrAddress(modalTxDetails.tx.from)"></b-form-input>
                <b-input-group-append class="ml-1">
                  <b-button size="sm" @click="copyToClipboard(modalTxDetails.tx.from);" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Copy to clipboard'"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                  <b-link size="sm" :href="'https://sepolia.etherscan.io/address/' + modalTxDetails.tx.from" target="_blank" variant="link" class="m-0 ml-1 p-0" v-b-popover.hover.top="'View in etherscan.io'">
                    <b-img rounded="0" width="16px" height="16px" src="images/etherscan-logo-circle.svg" blank-color="#777" target="_blank"></b-img>
                  </b-link>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalTxDetails.tx" label="To:" label-for="modal-tx-details-to" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
              <template slot="description">
                <div v-if="ensOrAddress(modalTxDetails.tx.to) != modalTxDetails.tx.to">
                  {{ modalTxDetails.tx.to }}
                </div>
              </template>
              <b-input-group size="sm" class="w-75">
                <b-form-input type="text" readonly size="sm" id="modal-tx-details-to" :value="ensOrAddress(modalTxDetails.tx.to)"></b-form-input>
                <b-input-group-append class="ml-1">
                  <b-button size="sm" @click="copyToClipboard(modalTxDetails.tx.to);" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Copy to clipboard'"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                  <b-link size="sm" :href="'https://sepolia.etherscan.io/address/' + modalTxDetails.tx.to" target="_blank" variant="link" class="m-0 ml-1 p-0" v-b-popover.hover.top="'View in etherscan.io'">
                    <b-img rounded="0" width="16px" height="16px" src="images/etherscan-logo-circle.svg" blank-color="#777" target="_blank"></b-img>
                  </b-link>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>

            <span v-if="modalTxDetails.tradeInputs" v-for="(tradeInput, tradeInputIndex) in modalTxDetails.tradeInputs" :key="tradeInputIndex">
                <b-form-group :label="'Action[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.action == 0 ? 'Fill' : (tradeInput.action == 1 ? 'Fill Or Kill' : 'Fill And Add Order')" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Buy/Sell[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.buySell == 0 ? 'Buy' : 'Sell'" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Base[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.base" class="w-75"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Quote[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.quote" class="w-75"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Price[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.price" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Target Price[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.targetPrice" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Expiry[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.expiry" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Tokens[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.tokens" class="w-50"></b-form-input>
                </b-form-group>

                <b-form-group :label="'Skip Check[' + tradeInputIndex + ']:'" label-size="sm" label-cols-sm="2" label-align-sm="right" class="mx-0 my-1 p-0">
                  <b-form-input type="text" readonly size="sm" :value="tradeInput.skipCheck ? 'Yes' : 'No'" class="w-50"></b-form-input>
                </b-form-group>

            </span>

            <div>
              <pre>
{{ modalTxDetails }}
              </pre>
            </div>
          </b-modal>

          <!-- 0:Home -->
          <b-card v-if="coinbase && settings.tabIndex == 0" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Home
            </template>
            <b-card-text class="m-0 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-1">
                  <b-button size="sm" :pressed.sync="settings.showFilter" @click="saveSettings" variant="link" v-b-popover.hover.top="'Show filter'"><span v-if="settings.showFilter"><b-icon-layout-sidebar-inset shift-v="+1" font-scale="1.0"></b-icon-layout-sidebar-inset></span><span v-else><b-icon-layout-sidebar shift-v="+1" font-scale="1.0"></b-icon-layout-sidebar></span></b-button>
                </div>
                <div v-if="Object.keys(settings.filters).length > 0" class="mt-0 pr-1">
                  <b-button size="sm" @click="resetFilters();" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Reset filters'">
                    <b-iconstack shift-v="-4" font-scale="1">
                      <b-icon stacked icon="funnel-fill" variant="info" scale="1"></b-icon>
                      <b-icon stacked icon="x" variant="danger" scale="1.3"></b-icon>
                    </b-iconstack>
                  </b-button>
                </div>
                <!-- <div class="mt-0 pr-1">
                  <b-form-input type="text" size="sm" v-model.trim="settings.pairsTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Base or quote symbol and name filter'" placeholder="🔍 sym/name regex" style="min-width: 8.0rem;"></b-form-input>
                </div> -->
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="!sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="syncCryptoPunksData(false)" variant="primary" v-b-popover.hover.top="'Sync CryptoPunksData. This will take ~10 minutes initially, and ~0.5 minutes subsequently'">Sync</b-button>
                </div>
                <div v-if="!sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="syncCryptoPunksData(true)" variant="outline-primary" v-b-popover.hover.top="'Sync CryptoPunksData. This will take ~10 minutes initially, and ~0.5 minutes subsequently'">Sync(devMode)</b-button>
                </div>
                <div class="mt-1" style="width: 350px;">
                  <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'{processed blocked number}/{latest block number}. Click the button on the right to stop this process. This process can be continued later'">
                    <b-progress-bar :value="sync.completed">
                      {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                    </b-progress-bar>
                  </b-progress>
                </div>
                <div class="ml-0 mt-1">
                  <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.punksTable.sortOption" @change="saveSettings" :options="punksSortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
                </div>
                <div class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.top="'# tokens'">{{ filteredSortedPunks.length + '/' + punkAttributes.length }}</font>
                </div>
                <div class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.punksTable.currentPage" @input="saveSettings" :total-rows="filteredSortedPunks.length" :per-page="settings.punksTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.punksTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Yeah. Page size'"></b-form-select>
                </div>
              </div>

              <b-row class="m-0 p-0">
                <b-col v-if="settings.showFilter" cols="2" class="m-0 p-0 border-0">
                  <b-card no-header no-body class="m-0 p-0 border-0">
                    <!-- <b-card-body class="m-0 p-1" style="flex-grow: 1; max-height: 1500px; overflow-y: auto;"> -->
                    <b-card-body class="m-0 px-2 py-1" style="flex-grow: 1; max-height: 1500px; overflow-y: auto;">
                      <div v-for="punkAttribute of punkAttributesWithTokenIds">
                        <b-card header-class="m-0 px-2 pt-2 pb-0" body-class="p-0" class="m-0 p-0 border-0">
                          <template #header>
                            <span variant="secondary" class="small truncate">
                              {{ slugToTitle(punkAttribute.attributeType) }}
                            </span>
                          </template>
                        </b-card>
                        <font size="-2">
                          <b-table small fixed striped sticky-header="200px" :fields="punkAttributesFields" :items="punkAttribute.attributeList" head-variant="light">
                            <template #cell(select)="data">
                              <b-form-checkbox size="sm" :checked="(settings.filters[punkAttribute.attributeType] && settings.filters[punkAttribute.attributeType][data.item.attribute]) ? 1 : 0" value="1" @change="filterChanged(punkAttribute.attributeType, data.item.attribute)"></b-form-checkbox>
                            </template>
                            <template #cell(attributeOption)="data">
                              {{ slugToTitle(data.item.attribute) }}
                            </template>
                            <template #cell(attributeTotal)="data">
                              {{ data.item.punks.length }}
                            </template>
                          </b-table>
                        </font>
                      </div>
                    </b-card-body>
                  </b-card>
                </b-col>
                <b-col class="m-0 p-0 pl-1">
                  <!-- <b-table small fixed striped responsive hover selectable select-mode="single" @row-selected="pairsRowSelected" :fields="pairsFields" :items="pagedFilteredSortedPairs" show-empty empty-html="Click Sync above to retrieve existing pairs" head-variant="light" class="mx-0 my-1"> -->
                  <b-table small fixed striped responsive hover :fields="punksFields" :items="pagedFilteredSortedPunks" show-empty empty-html="Click Sync above to retrieve punk history" head-variant="light" class="mx-0 my-1">
                    <template #cell(punkId)="data">
                      <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + data.item.punkId" v-b-popover.hover.bottom="'View in original website'" target="_blank">
                        {{ data.item.punkId }}
                      </b-link>
                    </template>
                    <template #cell(image)="data">
                      <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + data.item.punkId" v-b-popover.hover.bottom="'View in original website'" target="_blank">
                        <b-img-lazy width="100%" :src="'images/punks/punk' + data.item.punkId.toString().padStart(4, '0') + '.png'" style="background-color: #638596"/>
                      </b-link>
                    </template>
                    <template #cell(owner)="data">
                      <b-row v-if="tokens[1] && tokens[1][data.item.punkId]">
                        <b-col cols="1" class="m-0 p-0">v1</b-col>
                        <b-col>
                          <b-link :href="'https://etherscan.io/address/' + indexToAddress[tokens[1][data.item.punkId]]" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                            {{ ensOrAddress(tokens[1][data.item.punkId], 10) }}
                          </b-link>
                        </b-col>
                      </b-row>
                      <b-row v-if="tokens[2] && (data.item.punkId in tokens[2])">
                        <b-col cols="1" class="m-0 p-0">v2</b-col>
                        <b-col>
                          <b-link :href="'https://etherscan.io/address/' + indexToAddress[tokens[2][data.item.punkId]]" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                            {{ ensOrAddress(tokens[2][data.item.punkId], 10) }}
                          </b-link>
                        </b-col>
                      </b-row>
                      <b-row v-if="tokens[3] && tokens[3][data.item.punkId]">
                        <b-col cols="1" class="m-0 p-0">w1</b-col>
                        <b-col>
                          <b-link :href="'https://etherscan.io/address/' + indexToAddress[tokens[3][data.item.punkId]]" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                            {{ ensOrAddress(tokens[3][data.item.punkId], 10) }}
                          </b-link>
                        </b-col>
                      </b-row>
                      <b-row v-if="tokens[4] && tokens[4][data.item.punkId]">
                        <b-col cols="1" class="m-0 p-0">w2</b-col>
                        <b-col>
                          <b-link :href="'https://etherscan.io/address/' + indexToAddress[tokens[4][data.item.punkId]]" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                            {{ ensOrAddress(tokens[4][data.item.punkId], 10) }}
                          </b-link>
                        </b-col>
                      </b-row>
                    </template>
                    <template #cell(attribute)="data">
                      <span v-for="(attribute, attributeIndex) in data.item.attributes" v-bind:key="attributeIndex">
                        <!-- {{ /*slugToTitle(attribute.trait_type) + ':' +*/ slugToTitle(attribute.value) }} -->
                        <b-badge size="sm" pill variant="light" v-b-popover.hover.bottom="slugToTitle(attribute.trait_type)" class="mr-1">{{ slugToTitle(attribute.value) }}</b-badge>
                      </span>
                    </template>
                  </b-table>
                </b-col>
              </b-row>
            </b-card-text>
          </b-card>


          <!-- 1:Activity -->
          <b-card v-if="coinbase && settings.tabIndex == 1" class="m-0 p-0 border-0" body-class="m-1 p-0" header-class="m-0 p-2">
            <template #header>
              Activity
            </template>
            <b-card-text class="m-0 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div class="mt-1">
                  <b-button size="sm" :pressed.sync="settings.showFilter" @click="saveSettings" variant="link" v-b-popover.hover.top="'Show filter'"><span v-if="settings.showFilter"><b-icon-layout-sidebar-inset shift-v="+1" font-scale="1.0"></b-icon-layout-sidebar-inset></span><span v-else><b-icon-layout-sidebar shift-v="+1" font-scale="1.0"></b-icon-layout-sidebar></span></b-button>
                </div>
                <div v-if="Object.keys(settings.filters).length > 0" class="mt-0 pr-1">
                  <b-button size="sm" @click="resetFilters();" variant="link" class="m-0 p-0" v-b-popover.hover.top="'Reset filters'">
                    <b-iconstack shift-v="-4" font-scale="1">
                      <b-icon stacked icon="funnel-fill" variant="info" scale="1"></b-icon>
                      <b-icon stacked icon="x" variant="danger" scale="1.3"></b-icon>
                    </b-iconstack>
                  </b-button>
                </div>
                <!-- <div class="mt-0 pr-1">
                  <b-form-input type="text" size="sm" v-model.trim="settings.pairsTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Base or quote symbol and name filter'" placeholder="🔍 sym/name regex" style="min-width: 8.0rem;"></b-form-input>
                </div> -->

                <div class="mt-0 flex-grow-1">
                </div>

                <div class="mt-0 pr-1">
                  <b-form-checkbox-group size="sm" @input="saveSettings(); loadCurrentData();" v-model="settings.selectedContracts" :options="contractOptions" buttons button-variant="outline-primary" v-b-popover.hover.top="'Filter by [Wrapped] CryptoPunks V1 & V2'"></b-form-checkbox-group>
                </div>

                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="!sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="syncCryptoPunksData(false)" variant="primary" v-b-popover.hover.top="'Sync CryptoPunksData. This will take ~6 minutes initially, and ~10 seconds subsequently'">Sync</b-button>
                </div>
                <div v-if="!sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="syncCryptoPunksData(true)" variant="outline-primary" v-b-popover.hover.top="'Sync CryptoPunksData. This will take ~6 minutes initially, and ~10 seconds subsequently'">Sync(devMode)</b-button>
                </div>
                <div class="mt-1" style="width: 350px;">
                  <b-progress v-if="sync.section != null" height="1.5rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" v-b-popover.hover.top="'{processed blocked number}/{latest block number}. Click the button on the right to stop this process. This process can be continued later'">
                    <b-progress-bar :value="sync.completed">
                      {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                    </b-progress-bar>
                  </b-progress>
                </div>
                <div class="ml-0 mt-1">
                  <b-button v-if="sync.section != null" size="sm" @click="halt" variant="link" v-b-popover.hover.top="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.activityTable.sortOption" @change="saveSettings" :options="activitySortOptions" v-b-popover.hover.top="'Yeah. Sort'"></b-form-select>
                </div>
                <div class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.top="'# events'">{{ filteredSortedActivity.length + '/' + Object.keys(txs).length }}</font>
                </div>
                <div class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.activityTable.currentPage" @input="saveSettings" :total-rows="filteredSortedActivity.length" :per-page="settings.activityTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.activityTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.top="'Yeah. Page size'"></b-form-select>
                </div>
              </div>
              <b-row class="m-0 p-0">
                <b-col v-if="settings.showFilter" cols="2" class="m-0 p-0 border-0">
                  <b-card no-header no-body class="m-0 p-0 border-0">
                    <!-- <b-card-body class="m-0 p-1" style="flex-grow: 1; max-height: 1500px; overflow-y: auto;"> -->
                    <b-card-body class="m-0 px-2 py-1" style="flex-grow: 1; max-height: 1500px; overflow-y: auto;">
                      <div v-for="punkAttribute of punkAttributesWithTokenIds">
                        <b-card header-class="m-0 px-2 pt-2 pb-0" body-class="p-0" class="m-0 p-0 border-0">
                          <template #header>
                            <span variant="secondary" class="small truncate">
                              {{ slugToTitle(punkAttribute.attributeType) }}
                            </span>
                          </template>
                        </b-card>
                        <font size="-2">
                          <b-table small fixed striped sticky-header="200px" :fields="punkAttributesFields" :items="punkAttribute.attributeList" head-variant="light">
                            <template #cell(select)="data">
                              <b-form-checkbox size="sm" :checked="(settings.filters[punkAttribute.attributeType] && settings.filters[punkAttribute.attributeType][data.item.attribute]) ? 1 : 0" value="1" @change="filterChanged(punkAttribute.attributeType, data.item.attribute)"></b-form-checkbox>
                            </template>
                            <template #cell(attributeOption)="data">
                              {{ slugToTitle(data.item.attribute) }}
                            </template>
                            <template #cell(attributeTotal)="data">
                              {{ data.item.punks.length }}
                            </template>
                          </b-table>
                        </font>
                      </div>
                    </b-card-body>
                  </b-card>
                </b-col>
                <b-col class="m-0 p-0 pl-1">
                  <b-table small fixed striped responsive hover :fields="activityFields" :items="pagedFilteredSortedActivity" show-empty empty-html="Click Sync above to retrieve punk history" head-variant="light" class="mx-0 my-1">

                    <template #head(timestamp)="data">
                      <b-link size="sm" @click="toggleUTCMode" variant="link" v-b-popover.hover.top="'Switch between local time or UTC time'">{{ settings.utcMode ? 'UTC Time' : 'Local Time' }}</b-link>
                    </template>

                    <template #cell(number)="data">
                      {{ parseInt(data.index) + ((settings.activityTable.currentPage - 1) * settings.activityTable.pageSize) + 1 }}
                    </template>

                    <template #cell(timestamp)="data">
                      <font size="-1">
                        <b-link :href="'https://etherscan.io/tx/' + data.item[3]" v-b-popover.hover.bottom="'View tx in etherscan.io'" target="_blank">
                          {{ formatTimestamp(data.item[0]) }}
                        </b-link>
                        <!-- <font size="-2">
                          <b-link @click="showModalTxDetails(data.item);">🔍</b-link>
                        </font> -->
                      </font>
                      <br />
                      <font size="-2">
                        {{ data.item[1] + ':' + data.item[2] + ':' + data.item[3] }}
                      </font>
                    </template>

                    <template #cell(info)="data">
                      <font size="-2">
                        <pre>
{{ data.item }}
                        </pre>
                      </font>
                    </template>

                    <template #cell(events)="data">
                      <!-- {{ data.item[4] }} -->
                      <!-- <br /> -->
                      <font size="-1">
                        <span v-for="event in data.item[4]">
                          <!-- <b-badge pill variant="light" v-b-popover.hover="'logIndex'">{{ event[0] }}</b-badge> -->
                          <b-badge v-if="event[1] == 1" pill variant="success" v-b-popover.hover="'CryptoPunks V1. log #' + event[0]">v1</b-badge>
                          <b-badge v-else-if="event[1] == 2" pill variant="primary" v-b-popover.hover="'CryptoPunks V2. log #' + event[0]">v2</b-badge>
                          <b-badge v-else-if="event[1] == 3" pill variant="success" v-b-popover.hover="'WrappedCryptoPunks V1. log #' + event[0]">w1</b-badge>
                          <b-badge v-else-if="event[1] == 4" pill variant="primary" v-b-popover.hover="'WrappedCryptoPunks V2. log #' + event[0]">w2</b-badge>
                          <b-badge v-else pill variant="warning">???</b-badge>
                          <span v-if="event[2] == 0">
                            Assign
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[3]]" v-b-popover.hover.bottom="'to. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[3], 10) }}</b-badge>
                            </b-link>
                           <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + event[4]" v-b-popover.hover.bottom="'punkId. Click to view in cryptopunks.app'" target="_blank">
                             <b-badge pill variant="info">{{ event[4] }}</b-badge>
                           </b-link>
                          </span>
                          <span v-else-if="event[2] == 1">
                            Transfer
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[3]]" v-b-popover.hover.bottom="'from. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[3], 10) }}</b-badge>
                            </b-link>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[4]]" v-b-popover.hover.bottom="'to. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[4], 10) }}</b-badge>
                            </b-link>
                            <span v-if="event[1] <= 2">
                              <b-badge pill variant="light" v-b-popover.hover="'Amount'">{{ event[5] }}</b-badge>
                            </span>
                            <span v-else>
                              <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + event[5]" v-b-popover.hover.bottom="'punkId. Click to view in cryptopunks.app'" target="_blank">
                                <b-badge pill variant="info">{{ event[5] }}</b-badge>
                              </b-link>
                            </span>
                          </span>
                          <span v-else-if="event[2] == 2">
                            PunkTransfer
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[3]]" v-b-popover.hover.bottom="'from. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[3], 10) }}</b-badge>
                            </b-link>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[4]]" v-b-popover.hover.bottom="'to. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[4], 10) }}</b-badge>
                            </b-link>
                            <b-badge pill variant="light" v-b-popover.hover="'punkId'">{{ event[5] }}</b-badge>
                            <!-- // v1 v2 event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex); -->
                          </span>
                          <span v-else-if="event[2] == 3">
                            PunkOffered
                            <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + event[3]" v-b-popover.hover.bottom="'punkId. Click to view in cryptopunks.app'" target="_blank">
                              <b-badge pill variant="info">{{ event[3] }}</b-badge>
                            </b-link>
                            <b-badge pill variant="light" v-b-popover.hover="'Amount in ETH'">{{ formatETH(event[4]) }}</b-badge>
                            <b-link v-if="event[5] != 0" :href="'https://etherscan.io/address/' + indexToAddress[event[5]]" v-b-popover.hover.bottom="'Offered to. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[5], 10) }}</b-badge>
                            </b-link>
                            <!-- // v1 v2 event PunkOffered(uint indexed punkIndex, uint minValue, address indexed toAddress); -->
                          </span>
                          <span v-else-if="event[2] == 4">
                            PunkNoLongerForSale
                            <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + event[3]" v-b-popover.hover.bottom="'punkId. Click to view in cryptopunks.app'" target="_blank">
                              <b-badge pill variant="info">{{ event[3] }}</b-badge>
                            </b-link>
                            <!-- // v1 v2 event PunkNoLongerForSale(uint indexed punkIndex); -->
                          </span>
                          <span v-else-if="event[2] == 5">
                            PunkBidEntered
                            <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + event[3]" v-b-popover.hover.bottom="'punkId. Click to view in cryptopunks.app'" target="_blank">
                              <b-badge pill variant="info">{{ event[3] }}</b-badge>
                            </b-link>
                            <b-badge pill variant="light" v-b-popover.hover="'Amount in ETH'">{{ formatETH(event[4]) }}</b-badge>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[5]]" v-b-popover.hover.bottom="'from. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[5], 10) }}</b-badge>
                            </b-link>
                            <!-- //    v2 event PunkBidEntered(uint indexed punkIndex, uint value, address indexed fromAddress); -->
                          </span>
                          <span v-else-if="event[2] == 6">
                            PunkBidWithdrawn
                            <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + event[3]" v-b-popover.hover.bottom="'punkId. Click to view in cryptopunks.app'" target="_blank">
                              <b-badge pill variant="info">{{ event[3] }}</b-badge>
                            </b-link>
                            <b-badge pill variant="light" v-b-popover.hover="'Amount in ETH'">{{ formatETH(event[4]) }}</b-badge>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[5]]" v-b-popover.hover.bottom="'from. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[5], 10) }}</b-badge>
                            </b-link>
                            <!-- //    v2 event PunkBidWithdrawn(uint indexed punkIndex, uint value, address indexed fromAddress); -->
                          </span>
                          <span v-else-if="event[2] == 7">
                            PunkBought
                            <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + event[3]" v-b-popover.hover.bottom="'punkId. Click to view in cryptopunks.app'" target="_blank">
                              <b-badge pill variant="info">{{ event[3] }}</b-badge>
                            </b-link>
                            <b-badge pill variant="light" v-b-popover.hover="'Amount in ETH'">{{ formatETH(event[4]) }}</b-badge>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[5]]" v-b-popover.hover.bottom="'from. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[5], 10) }}</b-badge>
                            </b-link>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[6]]" v-b-popover.hover.bottom="'to. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[6], 10) }}</b-badge>
                            </b-link>
                            <!-- // v1 v2 event PunkBought(uint indexed punkIndex, uint value, address indexed fromAddress, address indexed toAddress); -->
                          </span>
                          <span v-else-if="event[2] == 8">
                            Approval
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[3]]" v-b-popover.hover.bottom="'owner. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[3], 10) }}</b-badge>
                            </b-link>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[4]]" v-b-popover.hover.bottom="'approved. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[4], 10) }}</b-badge>
                            </b-link>
                            <b-badge pill variant="light" v-b-popover.hover="'punkId'">{{ event[5] }}</b-badge>
                            <!-- // w1 w2 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); -->
                          </span>
                          <span v-else-if="event[2] == 9">
                            ApprovalForAll
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[3]]" v-b-popover.hover.bottom="'owner. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[3], 10) }}</b-badge>
                            </b-link>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[4]]" v-b-popover.hover.bottom="'operator. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[4], 10) }}</b-badge>
                            </b-link>
                            <b-badge pill variant="light" v-b-popover.hover="'approved'">{{ event[5] }}</b-badge>
                            <!-- // w1 w2 event ApprovalForAll(address indexed owner, address indexed operator, bool approved); -->
                          </span>
                          <span v-else-if="event[2] == 10">
                            OwnershipTransferred
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[3]]" v-b-popover.hover.bottom="'previousOwner. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[3], 10) }}</b-badge>
                            </b-link>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[4]]" v-b-popover.hover.bottom="'newOwner. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[4], 10) }}</b-badge>
                            </b-link>
                            <!-- // w1 w2 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); -->
                          </span>
                          <span v-else-if="event[2] == 11">
                            ProxyRegistered
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[3]]" v-b-popover.hover.bottom="'user. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[3], 10) }}</b-badge>
                            </b-link>
                            <b-link :href="'https://etherscan.io/address/' + indexToAddress[event[4]]" v-b-popover.hover.bottom="'proxy. Click to view in etherscan.io'" target="_blank">
                              <b-badge pill variant="warning">{{ ensOrAddress(event[4], 10) }}</b-badge>
                            </b-link>
                            <!-- //    w2 event ProxyRegistered(address user, address proxy); -->
                          </span>
                          &nbsp;&nbsp;

                          <!--
                          // v1 v2 event Assign(address indexed to, uint256 punkIndex);
                          // v1 v2 event Transfer(address indexed from, address indexed to, uint256 value);
                          // v1 v2 event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex);
                          // v1 v2 event PunkOffered(uint indexed punkIndex, uint minValue, address indexed toAddress);
                          // v1 v2 event PunkBought(uint indexed punkIndex, uint value, address indexed fromAddress, address indexed toAddress);
                          // v1 v2 event PunkNoLongerForSale(uint indexed punkIndex);
                          //    v2 event PunkBidEntered(uint indexed punkIndex, uint value, address indexed fromAddress);
                          //    v2 event PunkBidWithdrawn(uint indexed punkIndex, uint value, address indexed fromAddress);
                          // w1 w2 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
                          // w1 w2 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
                          // w1 w2 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
                          // w1 w2 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
                          //    w2 event Paused(address account);
                          //    w2 event Unpaused(address account);
                          //    w2 event ProxyRegistered(address user, address proxy);
                          -->
                        </span>
                      </font>
                    </template>
                    <!-- <template #cell(punkId)="data">
                      <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + data.item.punkId" v-b-popover.hover.bottom="'View in original website'" target="_blank">
                        {{ data.item.punkId }}
                      </b-link>
                    </template>
                    <template #cell(image)="data">
                      <b-link :href="'https://cryptopunks.app/cryptopunks/details/' + data.item.punkId" v-b-popover.hover.bottom="'View in original website'" target="_blank">
                        <b-img-lazy width="100%" :src="'images/punks/punk' + data.item.punkId.toString().padStart(4, '0') + '.png'" style="background-color: #638596"/>
                      </b-link>
                    </template>
                    <template #cell(attribute)="data">
                      <span v-for="(attribute, attributeIndex) in data.item.attributes" v-bind:key="attributeIndex">
                        <b-badge size="sm" pill variant="light" v-b-popover.hover.bottom="slugToTitle(attribute.trait_type)" class="mr-1">{{ slugToTitle(attribute.value) }}</b-badge>
                      </span>
                    </template> -->
                  </b-table>
                  <!-- <b-table small fixed striped responsive hover :items="pagedFilteredSortedActivity" show-empty empty-html="Click Sync above to retrieve punk activity" head-variant="light" class="mx-0 my-1">
                  </b-table> -->
                </b-col>
              </b-row>
            </b-card-text>
          </b-card>

        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chainId == '1' ? 'Mainnet' : 'Unsupported' }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>CryptoPunksData</i> &copy; Bok Consulting Pty Ltd 2023
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,

          settings: {
            selectedContracts: [],
            utcMode: false,
            tabIndex: 0,
            showFilter: false,
            showAdditionalFilters: false,
            filters: {},
            punksTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'punkidasc',
            },
            activityTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'txorderdsc',
            },
            editAccounts: false,
            accounts: {},
            accountsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'groupnameasc',
            },
            transfersTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'blocknumberdsc',
            },
            tokensTable: {
              tokenFilter: null,
              collectionFilter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'lastsaledsc',
            },
            version: 7,
          },

          contracts: [
            { name: "CryptoPunks V1", address: CRYPTOPUNKSV1ADDRESS, abi: CRYPTOPUNKSV1ABI, deploymentBlockNumber: CRYPTOPUNKSV1DEPLOYMENTBLOCKNUMBER },
            { name: "CryptoPunks V2", address: CRYPTOPUNKSV2ADDRESS, abi: CRYPTOPUNKSV2ABI, deploymentBlockNumber: CRYPTOPUNKSV2DEPLOYMENTBLOCKNUMBER },
            { name: "WrappedCryptoPunks V1", address: WRAPPEDCRYPTOPUNKSV1ADDRESS, abi: WRAPPEDCRYPTOPUNKSV1ABI, deploymentBlockNumber: WRAPPEDCRYPTOPUNKSV1DEPLOYMENTBLOCKNUMBER },
            { name: "WrappedCryptoPunks V2", address: WRAPPEDCRYPTOPUNKSV2ADDRESS, abi: WRAPPEDCRYPTOPUNKSV2ABI, deploymentBlockNumber: WRAPPEDCRYPTOPUNKSV2DEPLOYMENTBLOCKNUMBER },
          ],

          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },
          blockTimestamps: {},
          addressToIndex: {},
          indexToAddress: [],
          indexToName: {},
          txs: [],
          tokens: {},
          events: {},

          modalTxDetails: {
            item: null,
            tx: null,
            tradeInputs: null,
            data: null,
            token: null,
            collection: null,
          },

          punksSortOptions: [
            { value: 'punkidasc', text: '▲ PunkId' },
            { value: 'punkiddsc', text: '▼ PunkId' },
          ],
          activitySortOptions: [
            { value: 'txorderasc', text: '▲ TxOrder' },
            { value: 'txorderdsc', text: '▼ TxOrder' },
          ],
          contractOptions: [
            { text: 'v1', value: 1 },
            { text: 'v2', value: 2 },
            { text: 'w1', value: 3 },
            { text: 'w2', value: 4 }
          ],
          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],
          punksFields: [
            { key: 'punkId', label: 'PunkId', sortable: false, thStyle: 'width: 15%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'image', label: 'Image', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'owner', label: 'Owner', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'attribute', label: 'Attributes', sortable: false, thStyle: 'width: 50%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          activityFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'info', label: 'Info', sortable: false, thStyle: 'width: 35%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'events', label: 'Events', sortable: false, thStyle: 'width: 40%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          punkAttributesFields: [
            { key: 'select', label: '', thStyle: 'width: 10%;' },
            { key: 'attributeOption', label: 'Attribute' /*, sortable: true*/ },
            { key: 'attributeTotal', label: 'Count', /*sortable: true,*/ thStyle: 'width: 30%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          indexToEventTypes: [
            "Assign", // 0
            "Transfer", // 1
            "PunkTransfer", // 2
            "PunkOffered", // 3
            "PunkNoLongerForSale", // 4
            "PunkBidEntered", // 5
            "PunkBidWithdrawn", // 6
            "PunkBought", // 7
            "Approval", // 8
            "ApprovalForAll", // 9
            "OwnershipTransferred", // 10
            "ProxyRegistered", // 11
          ],
          db: {
            name: "cryptopunksdata088g",
            version: 1,
            schemaDefinition: {
              cache: '&objectName',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {
          eventTypesToIndex() {
            const results = {};
            for (const [eventTypeIndex, eventType] of this.indexToEventTypes.entries()) {
              results[eventType] = eventTypeIndex;
            }
            return results;
          },
          punkAttributes() {
            return PUNKATTRIBUTES;
          },
          punkAttributesWithTokenIds() {
            const collator = {};
            for (const [punkId, punkAttribute] of this.punkAttributes.entries()) {
              for (const attribute of punkAttribute) {
                const trait_type = attribute.trait_type;
                const value = attribute.value;
                if (!collator[trait_type]) {
                  collator[trait_type] = {};
                }
                if (!collator[trait_type][value]) {
                  collator[trait_type][value] = [punkId];
                } else {
                  collator[trait_type][value].push(punkId);
                }
              }
            }
            const results = [];
            for (const [attributeType, attributes] of Object.entries(collator)) {
              const attributeList = [];
              for (const [attribute, punks] of Object.entries(attributes)) {
                attributeList.push({ attribute, punks });
              }
              attributeList.sort((a, b) => a.punks.length - b.punks.length);
              results.push({ attributeType, attributeList });
            }
            results.sort((a, b) => ('' + a.attributeType).localeCompare(b.attributeType))
            return results;
          },
          filteredPunks() {
            const results = [];
            // console.log("filteredPunks - this.settings.filters: " + JSON.stringify(this.settings.filters));
            let stage1Data = this.punkAttributes;
            if (Object.keys(this.settings.filters).length == 0) {
              for (const [punkId, attributes] of this.punkAttributes.entries()) {
                results.push({ punkId, attributes });
              }
            } else {
              let selectedTokenIds = [];
              for (const [attributeType, attributeList] of Object.entries(this.settings.filters)) {
                let thisAttributeTypeTokenIds = [];
                for (const attribute of Object.keys(attributeList)) {
                  for (const attributeInfo of this.punkAttributesWithTokenIds) {
                    if (attributeInfo.attributeType == attributeType) {
                      const tokenIds = attributeInfo.attributeList.filter(e => e.attribute == attribute).map(e => e.punks).flat();
                      thisAttributeTypeTokenIds = [...thisAttributeTypeTokenIds, ...tokenIds];
                      break;
                    }
                  }
                }
                if (selectedTokenIds.length == 0) {
                  selectedTokenIds = thisAttributeTypeTokenIds;
                } else {
                  selectedTokenIds = selectedTokenIds.filter(tokenId => thisAttributeTypeTokenIds.includes(tokenId));
                }
              }
              for (const punkId of selectedTokenIds) {
                results.push({ punkId, attributes: this.punkAttributes[punkId] });
              }
            }
            // console.log(moment().format("HH:mm:ss") + " filteredPunks - results: " + JSON.stringify(results.slice(0, 10)) + ", ...");
            return results;
          },
          filteredSortedPunks() {
            let results = this.filteredPunks;
            if (this.settings.punksTable.sortOption == 'punkidasc') {
              results.sort((a, b) => {
                return a.punkId - b.punkId;
              });
            } else if (this.settings.punksTable.sortOption == 'punkiddsc') {
              results.sort((a, b) => {
                return b.punkId - a.punkId;
              });
            }
            return results;
          },
          pagedFilteredSortedPunks() {
            return this.filteredSortedPunks.slice((this.settings.punksTable.currentPage - 1) * this.settings.punksTable.pageSize, this.settings.punksTable.currentPage * this.settings.punksTable.pageSize);
          },

          filteredActivity() {
            const results = [];
            // console.log("filteredActivity - this.settings.filters: " + JSON.stringify(this.settings.filters));
            console.log(JSON.stringify(this.txs).substring(0, 1000));
            let count = 0;
            for (const tx of this.txs) {
              const timestamp = this.blockTimestamps[tx[0]] || "(unknown)";
              if (count < 3) {
                console.log(JSON.stringify([ timestamp, ...tx ]));
              }
              results.push([ timestamp, ...tx ]);
              count++;
            }
            // console.log(JSON.stringify(results));


            // for (const [txHash, txInfo] of Object.entries(this.txs)) {
            //   // const txSummary = count < 20 ? parsePunkTx(txHash, txInfo, this.addressToIndex) : undefined;
            //   // const txSummary = parsePunkTx(txHash, txInfo, this.addressToIndex);
            //   // if (txSummary) {
            //     const txSummary = undefined;
            //     results.push([ txHash, ...txInfo, txSummary ]);
            //   // }
            //   count++;
            // }
            // console.log("results[0..10]: " + JSON.stringify(results.slice(0, 5)));

            // let stage1Data = this.punkAttributes;
            // if (Object.keys(this.settings.filters).length == 0) {
            //   for (const [punkId, attributes] of this.punkAttributes.entries()) {
            //     results.push({ punkId, attributes });
            //   }
            // } else {
            //   let selectedTokenIds = [];
            //   for (const [attributeType, attributeList] of Object.entries(this.settings.filters)) {
            //     let thisAttributeTypeTokenIds = [];
            //     for (const attribute of Object.keys(attributeList)) {
            //       for (const attributeInfo of this.punkAttributesWithTokenIds) {
            //         if (attributeInfo.attributeType == attributeType) {
            //           const tokenIds = attributeInfo.attributeList.filter(e => e.attribute == attribute).map(e => e.punks).flat();
            //           thisAttributeTypeTokenIds = [...thisAttributeTypeTokenIds, ...tokenIds];
            //           break;
            //         }
            //       }
            //     }
            //     if (selectedTokenIds.length == 0) {
            //       selectedTokenIds = thisAttributeTypeTokenIds;
            //     } else {
            //       selectedTokenIds = selectedTokenIds.filter(tokenId => thisAttributeTypeTokenIds.includes(tokenId));
            //     }
            //   }
            //   for (const punkId of selectedTokenIds) {
            //     results.push({ punkId, attributes: this.punkAttributes[punkId] });
            //   }
            // }
            // console.log(moment().format("HH:mm:ss") + " filteredActivity - results: " + JSON.stringify(results.slice(0, 10)) + ", ...");
            return results;
          },
          filteredSortedActivity() {
            let results = this.filteredActivity;
            if (this.settings.activityTable.sortOption == 'txorderasc') {
              results.sort((a, b) => {
                if (a[1] == b[1]) {
                  a[2] - b[2];
                } else {
                  return a[1] - b[1];
                }
              });
            } else if (this.settings.activityTable.sortOption == 'txorderdsc') {
              results.sort((a, b) => {
                if (a[1] == b[1]) {
                  b[2] - a[2];
                } else {
                  return b[1] - a[1];
                }
              });
            }
            return results;
          },
          pagedFilteredSortedActivity() {
            return this.filteredSortedActivity.slice((this.settings.activityTable.currentPage - 1) * this.settings.activityTable.pageSize, this.settings.activityTable.currentPage * this.settings.activityTable.pageSize);
          },

        },

        // --- METHODS ---
        methods: {
          slugToTitle(slug) {
            var words = slug.toString().split("-");
            return words.map(function(word) {
              if (word == "3d" || word == "vr") {
                return word.toUpperCase();
              } else {
                return word.charAt(0).toUpperCase() + word.substring(1).toLowerCase();
              }
            }).join(' ');
          },

          async syncCryptoPunksData(devMode) {
            // v1 v2 event Assign(address indexed to, uint256 punkIndex);
            // v1 v2 event Transfer(address indexed from, address indexed to, uint256 value);
            // v1 v2 event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex);
            // v1 v2 event PunkOffered(uint indexed punkIndex, uint minValue, address indexed toAddress);
            // v1 v2 event PunkNoLongerForSale(uint indexed punkIndex);
            //    v2 event PunkBidEntered(uint indexed punkIndex, uint value, address indexed fromAddress);
            //    v2 event PunkBidWithdrawn(uint indexed punkIndex, uint value, address indexed fromAddress);
            // v1 v2 event PunkBought(uint indexed punkIndex, uint value, address indexed fromAddress, address indexed toAddress);
            // w1 w2 event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
            // w1 w2 event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
            // w1 w2 event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
            // w1 w2 event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
            //    w2 event Paused(address account);
            //    w2 event Unpaused(address account);
            //    w2 event ProxyRegistered(address user, address proxy);
            const CONFIRMATIONS = 100;
            // console.log(moment().format("HH:mm:ss") + " syncCryptoPunksData - chainId: " + this.chainId);
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.coinbase = await signer.getAddress();
            localStorage.cryptoPunksDataCoinbase = this.coinbase;
            const network = await provider.getNetwork();
            localStorage.cryptoPunksDataChainId = network.chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " syncCryptoPunksData - latestBlockNumber: " + latestBlockNumber + ", chainId: " + this.chainId);

            let indexToAddress = [];
            let addressToIndex = {};
            const indexToAddressDataItems = await db.cache.where("objectName").equals(this.chainId + "_indexToAddress").toArray();
            if (indexToAddressDataItems.length == 1) {
              indexToAddress = indexToAddressDataItems[0].object;
            }
            const addressToIndexDataItems = await db.cache.where("objectName").equals(this.chainId + "_addressToIndex").toArray();
            if (addressToIndexDataItems.length == 1) {
              addressToIndex = addressToIndexDataItems[0].object;
            }
            for (const address of [ADDRESS0, CRYPTOPUNKSV1ADDRESS, CRYPTOPUNKSV2ADDRESS, WRAPPEDCRYPTOPUNKSV1ADDRESS, WRAPPEDCRYPTOPUNKSV2ADDRESS, this.coinbase]) {
              if (!(address in addressToIndex)) {
                addressToIndex[address] = indexToAddress.length;
                indexToAddress.push(address);
              }
            }
            for (const process of this.contracts) {
              // console.log(moment().format("HH:mm:ss") + " Processing: " + process.name);
              const contract = new ethers.Contract(process.address, process.abi, provider);
              if (!(process.address in addressToIndex)) {
                addressToIndex[process.address] = indexToAddress.length;
                indexToAddress.push(process.address);
              }
              let events = {};
              let total = 0;
              let newEvents = 0;
              function processLogs(fromBlock, toBlock, logs) {
                total = parseInt(total) + logs.length;
                console.log(moment().format("HH:mm:ss") + " " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
                for (const event of logs) {
                  if (!event.removed) {
                    const logData = contract.interface.parseLog(event);
                    const txHash = event.transactionHash;
                    const blockNumber = event.blockNumber;
                    const txIndex = event.transactionIndex;
                    const logIndex = event.logIndex;
                    const eventType = logData.eventFragment.name;
                    const eventTypeIndex = t.eventTypesToIndex[eventType];
                    let record = null;
                    if (eventType == "Assign") {
                      const [to, punkIndex] = logData.args;
                      if (!(to in addressToIndex)) {
                        addressToIndex[to] = indexToAddress.length;
                        indexToAddress.push(to);
                      }
                      const toIndex = addressToIndex[to];
                      record = [eventTypeIndex, toIndex, parseInt(punkIndex)];
                    } else if (eventType == "Transfer") {
                      const [from, to, value] = logData.args;
                      for (const address of [from, to]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const fromIndex = addressToIndex[from];
                      const toIndex = addressToIndex[to];
                      record = [ eventTypeIndex, fromIndex, toIndex, parseInt(value) ];
                    } else if (eventType == "PunkTransfer") {
                      const [from, to, punkIndex] = logData.args;
                      for (const address of [from, to]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const fromIndex = addressToIndex[from];
                      const toIndex = addressToIndex[to];
                      record = [ eventTypeIndex, fromIndex, toIndex, parseInt(punkIndex)];
                    } else if (eventType == "PunkOffered") {
                      const [punkIndex, minValue, toAddress] = logData.args;
                      if (!(toAddress in addressToIndex)) {
                        addressToIndex[toAddress] = indexToAddress.length;
                        indexToAddress.push(toAddress);
                      }
                      const toAddressIndex = addressToIndex[toAddress];
                      record = [ eventTypeIndex, parseInt(punkIndex), minValue.toString(), toAddressIndex ];
                    } else if (eventType == "PunkNoLongerForSale") {
                      const [punkIndex] = logData.args;
                      record = [ eventTypeIndex, parseInt(punkIndex) ];
                    } else if (eventType == "PunkBidEntered") {
                      const [punkIndex, value, fromAddress] = logData.args;
                      if (!(fromAddress in addressToIndex)) {
                        addressToIndex[fromAddress] = indexToAddress.length;
                        indexToAddress.push(fromAddress);
                      }
                      const fromAddressIndex = addressToIndex[fromAddress];
                      record = [ eventTypeIndex, parseInt(punkIndex), value.toString(), fromAddressIndex ];
                    } else if (eventType == "PunkBidWithdrawn") {
                      const [punkIndex, value, fromAddress] = logData.args;
                      if (!(fromAddress in addressToIndex)) {
                        addressToIndex[fromAddress] = indexToAddress.length;
                        indexToAddress.push(fromAddress);
                      }
                      const fromAddressIndex = addressToIndex[fromAddress];
                      record = [ eventTypeIndex, parseInt(punkIndex), value.toString(), fromAddressIndex ];
                    } else if (eventType == "PunkBought") {
                      const [punkIndex, value, fromAddress, toAddress] = logData.args;
                      for (const address of [fromAddress, toAddress]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const fromAddressIndex = addressToIndex[fromAddress];
                      const toAddressIndex = addressToIndex[toAddress];
                      record = [ eventTypeIndex, parseInt(punkIndex), value.toString(), fromAddressIndex, toAddressIndex ];
                    } else if (eventType == "OwnershipTransferred") {
                      const [previousOwner, newOwner] = logData.args;
                      for (const address of [previousOwner, newOwner]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const previousOwnerIndex = addressToIndex[previousOwner];
                      const newOwnerIndex = addressToIndex[newOwner];
                      record = [ eventTypeIndex, previousOwnerIndex, newOwnerIndex ];
                    } else if (eventType == "Approval") {
                      const [owner, approved, tokenId] = logData.args;
                      for (const address of [owner, approved]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const ownerIndex = addressToIndex[owner];
                      const approvedIndex = addressToIndex[approved];
                      record = [ eventTypeIndex, ownerIndex, approvedIndex, tokenId.toString() ];
                    } else if (eventType == "ApprovalForAll") {
                      const [owner, operator, approved] = logData.args;
                      for (const address of [owner, operator]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const ownerIndex = addressToIndex[owner];
                      const operatorIndex = addressToIndex[operator];
                      record = [ eventTypeIndex, ownerIndex, operatorIndex, approved ];
                    } else if (eventType == "Paused") {
                      const [account] = logData.args;
                      if (!(account in addressToIndex)) {
                        addressToIndex[account] = indexToAddress.length;
                        indexToAddress.push(fromAddress);
                      }
                      const accountIndex = addressToIndex[account];
                      record = [ eventTypeIndex, accountIndex ];
                    } else if (eventType == "Unpaused") {
                      const [account] = logData.args;
                      if (!(account in addressToIndex)) {
                        addressToIndex[account] = indexToAddress.length;
                        indexToAddress.push(fromAddress);
                      }
                      const accountIndex = addressToIndex[account];
                      record = [ eventTypeIndex, accountIndex ];

                    } else if (eventType == "ProxyRegistered") {
                      const [user, proxy] = logData.args;
                      for (const address of [user, proxy]) {
                        if (!(address in addressToIndex)) {
                          addressToIndex[address] = indexToAddress.length;
                          indexToAddress.push(address);
                        }
                      }
                      const userIndex = addressToIndex[user];
                      const proxyIndex = addressToIndex[proxy];
                      record = [ eventTypeIndex, userIndex, proxyIndex ];

                    } else {
                      console.log("--- UNKNOWN eventType: " + eventType + " ---");
                    }
                    console.log(blockNumber + "." + txIndex + " " + JSON.stringify(record));
                    if (record) {
                      const confirmations = latestBlockNumber - blockNumber;
                      if (!(blockNumber in events)) {
                        events[blockNumber] = {};
                      }
                      if (!(txIndex in events[blockNumber])) {
                        events[blockNumber][txIndex] = [ txHash, {} ];
                      }
                      if (!(logIndex in events[blockNumber][txIndex][1])) {
                        events[blockNumber][txIndex][1][logIndex] = record;
                        newEvents++;
                      }
                    }
                  }
                }
              }
              const t = this;
              async function getLogs(fromBlock, toBlock, processLogs, section) {
                if (!t.sync.halt) {
                  try {
                    const filter = { address: process.address, fromBlock, toBlock, topics: [null, null, null] };
                    const eventLogs = await provider.getLogs(filter);
                    processLogs(fromBlock, toBlock, eventLogs);
                    t.sync.section = section;
                    t.sync.completed = toBlock;
                  } catch (e) {
                    const mid = parseInt((fromBlock + toBlock) / 2);
                    await getLogs(fromBlock, mid, processLogs, section);
                    await getLogs(parseInt(mid) + 1, toBlock, processLogs, section);
                  }
                }
              }
              const eventsDataItems = await db.cache.where("objectName").equals(this.chainId + "_" + process.address + "_events").toArray();
              if (eventsDataItems.length == 1) {
                const storedLatestBlockNumber = eventsDataItems[0].object.latestBlockNumber;
                events = eventsDataItems[0].object.events;
                // console.log(moment().format("HH:mm:ss") + " syncCryptoPunksData - storedLatestBlockNumber: " + storedLatestBlockNumber);
                // console.log(moment().format("HH:mm:ss") + " syncCryptoPunksData - events: " + JSON.stringify(events).substring(0, 1000));
                if (!devMode) {
                  Object.keys(events).forEach(function (key) {
                    const confirmations = storedLatestBlockNumber - key;
                    if (confirmations < CONFIRMATIONS) {
                      console.log("DELETING: " + key + " => " + confirmations + " " + JSON.stringify(events[key]));
                      delete events[key];
                    }
                  });
                }
              }
              const blockNumbers = Object.keys(events).sort((a, b) => { return b - a });
              const startBlock = blockNumbers.length > 0 ? parseInt(blockNumbers[0]) + 1: process.deploymentBlockNumber;
              this.sync.total = latestBlockNumber;
              this.sync.completed = startBlock;
              if (!devMode) {
                await getLogs(startBlock, latestBlockNumber, processLogs, process.name);
                Vue.set(this, "addressToIndex", addressToIndex);
                Vue.set(this, "indexToAddress", indexToAddress);
                await db.cache.put({ objectName: this.chainId + "_indexToAddress", object: indexToAddress }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                await db.cache.put({ objectName: this.chainId + "_addressToIndex", object: addressToIndex }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                console.log(moment().format("HH:mm:ss") + " syncCryptoPunksData - events: " + JSON.stringify(events));
                await db.cache.put({ objectName: this.chainId + "_" + process.address + "_events", object: { latestBlockNumber, events } }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }
            }
            if (!devMode) {
              await this.loadBlockTimestamps(db);
            }
            await this.processData(db);
            if (!devMode) {
              await this.loadCurrentData();
            }
            this.sync.section = null;
            this.sync.halt = false;
          },

          async loadBlockTimestamps(db) {
            console.log(moment().format("HH:mm:ss") + " loadBlockTimestamps");
            // TODO: Low priority - Handle blockTimestamp entries with unconfirmed blocks to handle reorgs
            const blockNumbersToProcess = [];
            for (const process of this.contracts) {
              const contractIndex = this.addressToIndex[process.address];
              const eventsDataItems = await db.cache.where("objectName").equals(this.chainId + "_" + process.address + "_events").toArray();
              if (eventsDataItems.length == 1) {
                const storedLatestBlockNumber = eventsDataItems[0].object.latestBlockNumber;
                events = eventsDataItems[0].object.events;
                for (const [blockNumber, txIndexes] of Object.entries(events)) {
                  if (!(blockNumber in this.blockTimestamps)) {
                    blockNumbersToProcess.push(blockNumber);
                  }
                }
              }
            }
            this.sync.completed = 0;
            this.sync.total = blockNumbersToProcess.length;
            this.sync.section = 'Block Timestamps';
            const BATCHSIZE = 1000;
            for (let i = 0; i < blockNumbersToProcess.length; i += BATCHSIZE) {
              const batch = blockNumbersToProcess.slice(i, parseInt(i) + BATCHSIZE);
              const data = await fetch(BLOCKTIMESTAMPSUBGRAPHURL, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Accept': 'application/json',
                },
                body: JSON.stringify({
                  query: BLOCKTIMESTAMPINQUERY,
                  variables: { blockNumbers: batch.map(e => parseInt(e)) },
                })
              }).then(response => response.json())
              .catch(function(e) {
                console.log("error: " + e);
              });
              const timestamps = data.data && data.data.blocks || [];
              for (const timestampItem of timestamps) {
                Vue.set(this.blockTimestamps, timestampItem.number, parseInt(timestampItem.timestamp));
              }
              this.sync.completed += timestamps.length;
              console.log(moment().format("HH:mm:ss") + " loadBlockTimestamps " + this.sync.completed + " of " + blockNumbersToProcess.length);
            }
            await db.cache.put({ objectName: this.chainId + "_blockTimestamps", object: this.blockTimestamps }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            this.sync.section = null;
          },

          async processData(db) {
            console.log(moment().format("HH:mm:ss") + " processData BEGIN");
            const combined = {};
            for (const process of this.contracts.slice(0, 4)) {
              console.log(moment().format("HH:mm:ss") + " processData: " + process.name);
              const contractIndex = this.addressToIndex[process.address];
              const eventsDataItems = await db.cache.where("objectName").equals(this.chainId + "_" + process.address + "_events").toArray();
              if (eventsDataItems.length == 1) {
                const storedLatestBlockNumber = eventsDataItems[0].object.latestBlockNumber;
                events = eventsDataItems[0].object.events;
                for (const [blockNumber, txIndexes] of Object.entries(events)) {
                  if (!(blockNumber in combined)) {
                    combined[blockNumber] = {};
                  }
                  const timestamp = this.blockTimestamps[blockNumber] || "(unknown)";
                  for (const [txIndex, txData] of Object.entries(txIndexes)) {
                    const [txHash, logs] = txData;
                    if (!(txIndex in combined[blockNumber])) {
                      combined[blockNumber][txIndex] = [ txHash, {} ];
                    }
                    for (const [logIndex, eventData] of Object.entries(logs)) {
                      combined[blockNumber][txIndex][1][logIndex] = [ contractIndex, ...eventData ];
                    }
                  }
                }
              }
            }

            // TODO: Handle w1 and w2
            const txs = [];
            const tokens = {};
            const offers = { "1": {}, "2": {} };
            const v2Bids = {};
            let lastToOwnerIndex = 0;
            for (const blockNumber of Object.keys(combined).sort((a, b) => parseInt(a) - parseInt(b))) {
              const txIndexes = combined[blockNumber];
              for (const txIndex of Object.keys(txIndexes).sort((a, b) => parseInt(a) - parseInt(b))) {
                const txData = txIndexes[txIndex];
                const [txHash, logs] = txData;
                const events = [];
                const contractIndexes = {};
                const punkIds = {};
                for (const logIndex of Object.keys(logs).sort((a, b) => parseInt(a) - parseInt(b))) {
                  const event = logs[logIndex];
                  const [ contractIndex, eventType ] = [ event[0], event[1] ];
                  if (!(contractIndex in contractIndexes)) {
                    contractIndexes[contractIndex] = 1;
                  }
                  // Assign
                  if (eventType == 0) {
                    if (!(contractIndex in tokens)) {
                      tokens[contractIndex] = {};
                    }
                    const [ ownerIndex, punkId ] = [ event[2], event[3].toString() ];
                    if (parseInt(punkId) < 10000) {
                      tokens[contractIndex][punkId] = ownerIndex;
                      if (!(punkId in punkIds)) {
                        punkIds[punkId] = 1;
                      }
                    }
                    if (parseInt(punkId) > 9999 || punkId.length > 5) {
                      console.log("  v1 Invalid punkId" + " " + blockNumber + " " + txIndex + " " + txHash + " " + logIndex + " " + contractIndex + " " + eventType + " " + JSON.stringify(event));
                    }
                    events.push([ logIndex, contractIndex, eventType, event[2], event[3] ]);

                  // Transfer - W1 & W2
                  } else if (eventType == 1) {
                    if (contractIndex == 3 || contractIndex == 4) {
                      if (!(contractIndex in tokens)) {
                        tokens[contractIndex] = {};
                      }
                      // console.log(blockNumber + " " + txIndex + " " + txHash + " " + logIndex + " " + contractIndex + " " + eventType + " " + JSON.stringify(event));
                      const [ fromOwnerIndex, toOwnerIndex, punkId ] = [ event[2], event[3], event[4].toString() ];
                      if (parseInt(punkId) < 10000) {
                        tokens[contractIndex][punkId] = toOwnerIndex;
                        if (!(punkId in punkIds)) {
                          punkIds[punkId] = 1;
                        }
                      }
                    } else {
                      const [ fromOwnerIndex, toOwnerIndex, punkId ] = [ event[2], event[3], event[4].toString() ];
                      lastToOwnerIndex = toOwnerIndex;
                    }
                    events.push([ logIndex, contractIndex, eventType, event[2], event[3], event[4] ]);

                  // PunkTransfer - V1 & V2 only
                  } else if (eventType == 2) {
                    const [ fromOwnerIndex, toOwnerIndex, punkId ] = [ event[2], event[3], event[4].toString() ];
                    if (parseInt(punkId) < 10000) {
                      tokens[contractIndex][punkId] = toOwnerIndex;
                      if (!(punkId in punkIds)) {
                        punkIds[punkId] = 1;
                      }
                    }
                    // console.log(blockNumber + " " + txIndex + " " + txHash + " " + logIndex + " " + contractIndex + " " + eventType + " " + JSON.stringify(event));
                    events.push([ logIndex, contractIndex, eventType, event[2], event[3], event[4] ]);

                  // PunkOffered - V1 & V2
                  } else if (eventType == 3) {
                    const [ punkId, minValue, toOwnerIndex ] = [ event[2], event[3].toString(), event[4] ];
                    offers[contractIndex][punkId] = { minValue, toOwnerIndex };
                    if (!(punkId in punkIds)) {
                      punkIds[punkId] = 1;
                    }
                    if (punkId == 7144) {
                      console.log("PunkOffered " + blockNumber + " " + txIndex + " " + txHash + " " + logIndex + " " + contractIndex + " " + eventType + " " + JSON.stringify(event));
                      console.log("  offers[contractIndex][7144]: " + JSON.stringify(offers[contractIndex][7144]));
                    }
                    events.push([ logIndex, contractIndex, eventType, event[2], event[3], event[4] ]);

                  // PunkNoLongerForSale - V1 & V2
                  } else if (eventType == 4) {
                    const [ punkId ] = [ event[2] ];
                    delete offers[contractIndex][punkId];
                    if (!(punkId in punkIds)) {
                      punkIds[punkId] = 1;
                    }
                    if (punkId == 7144) {
                      console.log("PunkNoLongerForSale " + blockNumber + " " + txIndex + " " + txHash + " " + logIndex + " " + contractIndex + " " + eventType + " " + JSON.stringify(event));
                      console.log("  offers[contractIndex][7144]: " + JSON.stringify(offers[contractIndex][7144]));
                    }
                    events.push([ logIndex, contractIndex, eventType, event[2] ]);

                  // PunkBidEntered - V2
                  } else if (eventType == 5) {
                    const [ punkId, value, fromOwnerIndex ] = [ event[2], event[3].toString(), event[4] ];
                    v2Bids[punkId] = { value, fromOwnerIndex };
                    if (!(punkId in punkIds)) {
                      punkIds[punkId] = 1;
                    }
                    // if (punkId == 0) {
                    //   console.log("PunkBidEntered " + blockNumber + " " + txIndex + " " + txHash + " " + logIndex + " " + contractIndex + " " + eventType + " " + JSON.stringify(event));
                    //   console.log("  v2Bids[0]: " + JSON.stringify(v2Bids[0]));
                    // }
                    events.push([ logIndex, contractIndex, eventType, event[2], event[3], event[4] ]);

                  // PunkBidWithdrawn - V2
                  } else if (eventType == 6) {
                    const [ punkId, value, fromOwnerIndex ] = [ event[2], event[3].toString(), event[4] ];
                    delete v2Bids[punkId];
                    if (!(punkId in punkIds)) {
                      punkIds[punkId] = 1;
                    }
                    // if (punkId == 0) {
                    //   console.log("PunkBidWithdrawn " + blockNumber + " " + txIndex + " " + txHash + " " + logIndex + " " + contractIndex + " " + eventType + " " + JSON.stringify(event));
                    //   console.log("  v2Bids[0]: " + JSON.stringify(v2Bids[0]));
                    // }
                    events.push([ logIndex, contractIndex, eventType, event[2], event[3], event[4] ]);

                  // PunkBought - V1 & V2
                  } else if (eventType == 7) {
                    let [ punkId, value, fromOwnerIndex, toOwnerIndex ] = [ event[2].toString(), event[3].toString(), event[4], event[5] ];
                    // acceptBidForPunk() bug where value = 0 and fromOwner = 0x0
                    if (value == 0 && toOwnerIndex == 0) {
                      value = v2Bids[punkId].value;
                      toOwnerIndex = v2Bids[punkId].fromOwnerIndex;
                      delete v2Bids[punkId];
                    }
                    if (parseInt(punkId) < 10000) {
                      tokens[contractIndex][punkId] = toOwnerIndex;
                      if (!(punkId in punkIds)) {
                        punkIds[punkId] = 1;
                      }
                    }
                    events.push([ logIndex, contractIndex, eventType, event[2], value, fromOwnerIndex, toOwnerIndex ]);
                    // if (punkId == 0) {
                    //   console.log("PunkBought " + blockNumber + " " + txIndex + " " + txHash + " " + logIndex + " " + contractIndex + " " + eventType + " " + JSON.stringify(event));
                    //   console.log("  v2Bids[0]: " + JSON.stringify(v2Bids[0]));
                    // }

                  // Approval - W1 & W2
                  } else if (eventType == 8) {
                    events.push([ logIndex, contractIndex, eventType, event[2], event[3], event[4] ]);

                  // ApprovalForAll - W1 & W2
                  } else if (eventType == 9) {
                    events.push([ logIndex, contractIndex, eventType, event[2], event[3], event[4] ]);

                  // OwnershipTransferred - ? W1 & W2
                  } else if (eventType == 10) {
                    // Not captured

                  // ProxyRegistered - W2
                  } else if (eventType == 11) {
                    events.push([ logIndex, contractIndex, eventType, event[2], event[3] ]);

                  }
                }
                txs.push([ blockNumber, txIndex, txHash, events, Object.keys(contractIndexes).map(e => parseInt(e)), Object.keys(punkIds).map(e => parseInt(e)) ]);
              }
            }

            console.log(moment().format("HH:mm:ss") + " processData - txs: " + JSON.stringify(txs));
            await db.cache.put({ objectName: this.chainId + "_txs", object: txs }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            this.txs = txs;

            // V1 1416, 1838 and 1841 are unclaimed, Due to claim of invalid punkIds 9845944 (0x39d77a95637640b6291bea0b015be4f6578c95f9a57af6a9399dabd70b56d50c), 76623 (0xdc37a82d43eb253077abd4618683efea615fc8573bfc669568fab04098ab24b1) and 0xffff...ffff (0x7da83b5002251ca83537aef8833f443263a9109a1ccca502b0b03a0529813aa2)
            // V2 1416, 1838 and 1841 were assigned to 0x5b098b00621eda6a96b7a476220661ad265f083f
            for (let punkId = 0; punkId < 10000; punkId++) {
              if (!(punkId in tokens[1])) {
                // console.log("Not found - punkId: " + punkId);
                tokens[1][punkId] = 0; // 0x0000...0000
              }
            }
            // console.log("tokens[2][9478]: " + JSON.stringify(this.indexToAddress[tokens[2][9478]], null, 2));
            // console.log("tokens[2]: " + JSON.stringify(tokens[2], null, 2));
            await db.cache.put({ objectName: this.chainId + "_tokens", object: tokens }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            this.tokens = tokens;

            // console.log(moment().format("HH:mm:ss") + " processData - combined: " + JSON.stringify(combined));
            // console.log(moment().format("HH:mm:ss") + " processData - combined['18527112']: " + JSON.stringify(combined['18527112']));
            // console.log(moment().format("HH:mm:ss") + " processData - Object.keys(combined).length: " + Object.keys(combined).length);
            console.log(moment().format("HH:mm:ss") + " processData END");
          },

          async loadCurrentData() {
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            console.log(moment().format("HH:mm:ss") + " loadCurrentData BEGIN: " + JSON.stringify(this.settings.selectedContracts));
            const indexToAddressDataItems = await db.cache.where("objectName").equals(this.chainId + "_indexToAddress").toArray();
            if (indexToAddressDataItems.length == 1) {
              Vue.set(this, 'indexToAddress', indexToAddressDataItems[0].object);
            }
            const addressToIndexDataItems = await db.cache.where("objectName").equals(this.chainId + "_addressToIndex").toArray();
            if (addressToIndexDataItems.length == 1) {
              Vue.set(this, 'addressToIndex', addressToIndexDataItems[0].object);
            }
            const blockTimestampsDataItems = await db.cache.where("objectName").equals(this.chainId + "_blockTimestamps").toArray();
            if (blockTimestampsDataItems.length == 1) {
              Vue.set(this, 'blockTimestamps', blockTimestampsDataItems[0].object);
            }
            const tokensDataItems = await db.cache.where("objectName").equals(this.chainId + "_tokens").toArray();
            if (tokensDataItems.length == 1) {
              Vue.set(this, 'tokens', tokensDataItems[0].object);
            }
            const txsDataItems = await db.cache.where("objectName").equals(this.chainId + "_txs").toArray();
            if (txsDataItems.length == 1) {
              Vue.set(this, 'txs', txsDataItems[0].object);
            }
            // let count = 0;
            // const txs = {};
            // for (const process of this.contracts) {
            //   // console.log(moment().format("HH:mm:ss") + " loadCurrentData - processing: " + process.name);
            //   const contractIndex = this.addressToIndex[process.address];
            //   if (this.settings.selectedContracts.length == 0 || this.settings.selectedContracts.includes(contractIndex)) {
            //     const eventsDataItems = await db.cache.where("objectName").equals(this.chainId + "_" + process.address + "_events").toArray();
            //     if (eventsDataItems.length == 1) {
            //       const storedLatestBlockNumber = eventsDataItems[0].object.latestBlockNumber;
            //       events = eventsDataItems[0].object.events;
            //       // console.log(moment().format("HH:mm:ss") + " loadCurrentData - storedLatestBlockNumber: " + storedLatestBlockNumber);
            //       // console.log(moment().format("HH:mm:ss") + " loadCurrentData - events: " + JSON.stringify(events).substring(0, 1000));
            //       // Object.keys(events).forEach(function (key) {
            //       //   if ('unconfirmed' in events[key]) {
            //       //     console.log("DELETING: " + key + " => " + JSON.stringify(events[key]));
            //       //     delete events[key];
            //       //   }
            //       // });
            //       for (const [blockNumber, txIndexes] of Object.entries(events)) {
            //         const timestamp = this.blockTimestamps[blockNumber] || "(unknown)";
            //         for (const [txIndex, txData] of Object.entries(txIndexes)) {
            //           if (!(txData[0] in txs)) {
            //             txs[txData[0]] = [ parseInt(blockNumber), parseInt(timestamp), parseInt(txIndex), [] ];
            //           }
            //           for (const [logIndex, eventInfo] of Object.entries(txData[1])) {
            //             txs[txData[0]][3].push([ parseInt(logIndex), contractIndex, ...eventInfo ]);
            //             // if ((count % 10000) == 0) {
            //             //   console.log(count + " " + blockNumber + "/" + txIndex + "/" + txData[0] + "/" + logIndex + " => " + JSON.stringify(eventInfo));
            //             // }
            //             count++
            //           }
            //         }
            //       }
            //     }
            //   }
            // }
            // this.txs = txs;
            db.close();
            console.log(moment().format("HH:mm:ss") + " loadCurrentData END");
          },

          saveSettings() {
            localStorage.cryptoPunksDataSettings = JSON.stringify(this.settings);
          },
          toggleUTCMode() {
            if (this.settings.utcMode) {
              Vue.set(this.settings, 'utcMode', false);
            } else {
              Vue.set(this.settings, 'utcMode', true);
            }
            this.saveSettings();
          },
          filterChanged(dataType, option) {
            if (!this.settings.filters[dataType]) {
              Vue.set(this.settings.filters, dataType, {});
            }
            if (this.settings.filters[dataType][option]) {
              Vue.delete(this.settings.filters[dataType], option);
              if (Object.keys(this.settings.filters[dataType]) == 0) {
                Vue.delete(this.settings.filters, dataType);
              }
            } else {
              Vue.set(this.settings.filters[dataType], option, true);
            }
            this.saveSettings();
          },
          resetFilters() {
            Vue.set(this.settings, 'filters', {});
            this.saveSettings();
          },


          async syncAll(blockNumber) {
            console.log(moment().format("HH:mm:ss") + " syncAll - blockNumber: " + blockNumber + ", chainId: " + this.chainId);
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            // console.log("latestBlockNumber: " + latestBlockNumber);
            // const CONFIRMATIONS = 10;
            // const confirmedBlockNumber = block && block.number && (block.number - CONFIRMATIONS) || null;
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const context = { provider, latestBlockNumber, db };
            if (this.chainId == CHAINID_SEPOLIA) {
              await this.syncChadexEvents(context);
              await this.syncChadexPairs(context);
              await this.syncChadexPair(context);
            }
            db.close();
          },
          async syncAllENSNames(context) {
            console.log("syncAllENSNames");
            const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, context.provider);

            let indexToAddress = [];
            let addressToIndex = {};
            const indexToAddressDataItems = await context.db.cache.where("objectName").equals(CHAINID_SEPOLIA + "_indexToAddress").toArray();
            if (indexToAddressDataItems.length == 1) {
              indexToAddress = indexToAddressDataItems[0].object;
              console.log("indexToAddress: " + JSON.stringify(indexToAddress));
            }
            const addressToIndexDataItems = await context.db.cache.where("objectName").equals(CHAINID_SEPOLIA + "_addressToIndex").toArray();
            if (addressToIndexDataItems.length == 1) {
              addressToIndex = addressToIndexDataItems[0].object;
              console.log("addressToIndex: " + JSON.stringify(addressToIndex));
            }

            const addresses = indexToAddress;
            // addresses.sort();

            const MAXBATCHSIZE = 1000;
            let batchSize = MAXBATCHSIZE;
            let completed = 0;
            let done = false;
            let start = completed;
            do {
              let end = parseInt(start) + batchSize - 1;
              if (end > addresses.length) {
                end = addresses.length;
              }
              try {
                const batch = addresses.slice(start, end + 1);
                // console.log("batch: " + JSON.stringify(batch, null, 2));
                const allnames = await ensReverseRecordsContract.getNames(batch);
                // console.log("allnames: " + JSON.stringify(allnames, null, 2));
                // console.log(start + " - " + end + " " + batch.length);
                for (let j = 0; j < batch.length; j++) {
                  const account = batch[j];
                  const name = allnames[j];
                  // const normalized = normalize(account);
                  if (name.length > 0) {
                    // console.log(account + " => " + name);
                    Vue.set(this.indexToName, addressToIndex[account], name);
                  }
                }
                start = parseInt(end) + 1;
              } catch (e) {
                if (batchSize > 1) {
                  batchSize = parseInt(batchSize / 2);
                } else {
                  console.log("Skipping #" + start + " " + addresses[start]);
                  start = parseInt(start) + 1;
                  batchSize = MAXBATCHSIZE;
                }
              }
              done = start > indexToAddress.length;
            } while (!done);
            // console.log("this.indexToName: " + JSON.stringify(this.indexToName, null, 2));
            await context.db.cache.put({ objectName: CHAINID_MAINNET + "_indexToName", object: this.indexToName }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
          },
          async syncENSNames(context, newAccounts) {
            this.sync.completed = 0;
            this.sync.total = newAccounts.length;
            this.sync.section = context.symbol + ' ENS';
            const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, context.provider);

            const MAXBATCHSIZE = 1000;
            let batchSize = MAXBATCHSIZE;
            let completed = 0;
            let start = completed;
            do {
              let end = parseInt(start) + batchSize - 1;
              if (end > newAccounts.length) {
                end = newAccounts.length;
              }
              try {
                const batch = newAccounts.slice(start, end + 1);
                const allnames = await ensReverseRecordsContract.getNames(batch);
                for (let j = 0; j < batch.length; j++) {
                  const account = batch[j];
                  const name = allnames[j];
                  // const normalized = normalize(account);
                  if (name.length > 0) {
                    // console.log(account + " => " + name);
                    Vue.set(this.indexToName, this.addressToIndex[account], name);
                  }
                }
                this.sync.completed += batch.length;
                console.log(moment().format("HH:mm:ss") + " syncENSNames " + this.sync.completed + " of " + newAccounts.length);
                start = parseInt(end) + 1;
              } catch (e) {
                if (batchSize > 1) {
                  batchSize = parseInt(batchSize / 2);
                } else {
                  console.log("Skipping #" + start + " " + newAccounts[start]);
                  start = parseInt(start) + 1;
                  batchSize = MAXBATCHSIZE;
                }
              }
            } while (start <= newAccounts.length);


            //
            //
            // const BATCHSIZE = 5;
            // for (let i = 0; i < newAccounts.length; i += BATCHSIZE) {
            //   const batch = newAccounts.slice(i, parseInt(i) + BATCHSIZE);
            //   console.log("batch: " + batch);
            //   try {
            //     const allnames = await ensReverseRecordsContract.getNames(batch);
            //     console.log("allnames: " + allnames);
            //     for (let j = 0; j < batch.length; j++) {
            //       const account = batch[j];
            //       const name = allnames[j];
            //       // const normalized = normalize(account);
            //       // console.log(account + " => " + name);
            //       Vue.set(this.indexToName, account, name);
            //     }
            //     this.sync.completed += batch.length;
            //   } catch (e) {
            //     console.log("ENS getNames: " + e);
            //   }
            // }
            await context.db.cache.put({ objectName: "indexToName", object: this.indexToName }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
          },

          async halt() {
            this.sync.halt = true;
            console.log("this.sync.halt: " + this.sync.halt);
          },
          commify(n) {
            if (n != null) {
              return ethers.utils.commify(n);
            }
            return null;
          },
          sanitise(str, length = 32) {
            let result = str && str.replace(/[^a-z0-9 \.,_-💪]/gim,"_").trim() || "(null)";
            if (result && length > 0) {
              result = result.substring(0, length);
            }
            return result;
          },
          formatETH(e) {
            try {
              return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(9) : null;
            } catch (err) {
            }
            return e.toFixed(9);
          },
          formatERC20(e, decimals = 18) {
            try {
              return e ? ethers.utils.formatUnits(e, decimals) : null;
            } catch (err) {
            }
            return e.toString();
          },
          formatRate(e, decimals = 18, fixed = 10) {
            try {
              return e ? parseFloat(ethers.utils.formatUnits(e, decimals)).toFixed(fixed) : null;
            } catch (err) {
            }
            return e.toString();
          },
          formatTimestamp(ts) {
            if (ts != null) {
              if (this.settings.utcMode) {
                return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
              } else {
                return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
              }
            }
            return null;
          },
          formatExpiryShort(unixtime) {
            if (!unixtime) {
              return "no expiry";
            } else {
              if (unixtime > moment().unix()) {
                return moment.unix(unixtime).fromNow();
              } else {
                return "expired";
              }
            }
          },
          formatExpiry(unixtime) {
            if (!unixtime) {
              return "no expiry";
            } else {
              return moment.unix(unixtime).format("YYYY-MM-DD HH:mm:ss");
            }
          },
          formatTimeDiff(unixtime) {
            if (!unixtime) {
              return "";
            } else {
              return moment.unix(unixtime).fromNow();
            }
          },
          ensOrAddress(addressOrAddressIndex, length = 0) {
            let result = null;
            if (new RegExp('^[0-9,]+$').test(addressOrAddressIndex)) {
              // result = this.indexToName[addressOrAddressIndex];
              result = this.indexToAddress[addressOrAddressIndex];
            } else {
              result = this.indexToName[this.addressToIndex[addressOrAddressIndex]] || addressOrAddressIndex;
            }
            if (result && length > 0) {
              result = result.substring(0, length);
            }
            return result;
          },
          exportTxHashes() {
            console.log("exportTxHashes");
            var dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(this.txHashes));
            var link = document.createElement("a");
            link.setAttribute("href", dataStr);
            link.setAttribute("download", "txhashes.json");
            document.body.appendChild(link); // Required for FF
            link.click();
          },
          exportAccounts() {
            console.log("exportAccounts");
            const rows = [
                ["No", "Address", "Name", "ENSName", "Group", "Sync", "Include"],
            ];
            let i = 1;
            for (const result of this.filteredSortedAccounts) {
              rows.push([
                i,
                result.address,
                result.name,
                result.ensName,
                result.group,
                result.sync ? "y" : "n",
                result.include ? "y" : "n",
              ]);
              i++;
            }
            let tsvContent = "data:text/tsv;charset=utf-8," + rows.map(e => e.join("\t")).join("\n");
            var encodedUri = encodeURI(tsvContent);
            var link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "mynfts_account_export-" + moment().format("YYYY-MM-DD-HH-mm-ss") + ".tsv");
            document.body.appendChild(link); // Required for FF
            link.click(); // This will download the data with the specified file name
          },
          // async backupFilesChange(fileName, fileList) {
          //   const reader = new FileReader();
          //   this.restoreAddresses = [];
          //   const t = this;
          //   reader.onload = function (event) {
          //     const data = event.target.result;
          //     const lines = data.split("\n");
          //     for (const line of lines) {
          //       const fields = line.split("\t");
          //       // console.log(JSON.stringify(fields));
          //       if (fields[0] != "No") {
          //         const [number, address, name, ensName, group, sync, include]  = fields;
          //         t.restoreAddresses.push({ address, name, ensName, group, sync, include });
          //       }
          //     }
          //   };
          //   await reader.readAsText(fileList[0]);
          // },
          // restoreFromBackup() {
          //   if (this.restoreAddresses) {
          //     for (const addressData of this.restoreAddresses) {
          //       if (!(addressData.address in this.settings.accounts)) {
          //         console.log("Adding: " + JSON.stringify(addressData));
          //         Vue.set(this.settings.accounts, addressData.address, {
          //           name: addressData.name,
          //           ensName: null,
          //           group: addressData.group,
          //           sync: true,
          //           include: true,
          //         });
          //       } else {
          //         console.log("Discarding duplicate: " + JSON.stringify(addressData));
          //       }
          //     }
          //     this.saveSettings();
          //   }
          // },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          async connectToWeb3() {
            console.log(moment().format("HH:mm:ss") + " connectToWeb3");
            if (!window.ethereum) {
              this.connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                this.connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                this.connected = false;
              }
            }
            // console.log(moment().format("HH:mm:ss") + " connectToWeb3 - connected: " + this.connected);
            if (!this.connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const t = this;
              // console.log(moment().format("HH:mm:ss") + " connectToWeb3 - installing listeners");
              function handleChainChanged(_chainId) {
                t.chainId = _chainId;
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
                alert('Ethereum chain has changed - reloading this page.')
                window.location.reload();
              }
              window.ethereum.on('chainChanged', handleChainChanged);
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              async function handleAccountsChanged(accounts) {
                const signer = provider.getSigner();
                t.coinbase = await signer.getAddress();
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
              }
              window.ethereum.on('accountsChanged', handleAccountsChanged);
              async function handleNewBlock(blockNumber) {
                // console.log(moment().format("HH:mm:ss") + " handleNewBlock - New Block #" + blockNumber);
                const block = await provider.getBlock();
                t.blockNumber = blockNumber;
                t.timestamp = block.timestamp;
                await t.syncAll(blockNumber);
              }
              provider.on("block", handleNewBlock);
              const signer = provider.getSigner();
              this.coinbase = await signer.getAddress();
              const network = await provider.getNetwork();
              this.chainId = network.chainId;
              // console.log(moment().format("HH:mm:ss") + " connectToWeb3 - chainId: " + this.chainId);
            }
          },
          // TODO: Delete
          async processIt(action, parameters = null) {
            console.log("processIt - action: " + action + ", parameters: " + parameters);
            let connected = true;
            if (!window.ethereum) {
              connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                connected = false;
              }
            }
            if (!connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const signer = provider.getSigner();
              const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
              const erc721Helper = new ethers.Contract(ERC721HELPERADDRESS_SEPOLIA, ERC721HELPERABI, provider);
              this.coinbase = await signer.getAddress();
              localStorage.cryptoPunksDataCoinbase = this.coinbase;
              const network = await provider.getNetwork();
              console.log("network: " + JSON.stringify(network));
              localStorage.cryptoPunksDataChainId = network.chainId;
              this.chainId = network.chainId;
              const block = await provider.getBlock("latest");
              const blockNumber = block.number;
              const timestamp = block.timestamp;

              provider.off("block");
              // provider.removeAllListeners("block");
              provider.on("block", async (n) => {
                console.log(moment().format("HH:mm:ss") + " " + JSON.stringify(n));
              });
              const listenerCount = provider.listenerCount("block");
              // console.log("listenerCount: " + listenerCount);

              const ENSOWNERBATCHSIZE = 100; // 500 fails occassionally

              const db = new Dexie(this.db.name);
              db.version(this.db.version).stores(this.db.schemaDefinition);

              if (action == "retrieveMainCollection") {
                console.log("retrieveMainCollection");
                let continuation = null;
                this.sync.completed = 0;
                this.sync.total = null;
                this.sync.section = "Main collection";
                const mainTokens = {};
                this.mainToken.collection.name = null;
                do {
                  let url = "https://api.reservoir.tools/tokens/v5?contract=" + this.settings.mainCollection + "&limit=100" +
                    (continuation != null ? "&continuation=" + continuation : '');
                  console.log("url: " + url);
                  const data = await fetch(url)
                    .then(handleErrors)
                    .then(response => response.json())
                    .catch(function(error) {
                       console.log("ERROR - updateCollection: " + error);
                       // state.sync.error = true;
                       return [];
                    });
                  continuation = data.continuation;
                  if (data && data.tokens) {
                    for (const tokenData of data.tokens) {
                      const token = tokenData.token;
                      mainTokens[token.tokenId] = {
                        owner: token.owner,
                        image: token.image,
                      };
                      if (this.mainToken.collection.name == null) {
                        this.mainToken.collection.name = token.collection.name;
                        this.mainToken.collection.image = token.collection.image;
                        this.mainToken.collection.slug = token.collection.slug;
                      }
                    }
                  }
                  this.sync.completed = Object.keys(mainTokens).length;
                  await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                } while (continuation != null /*&& !this.sync.halt && !state.sync.error */);

                const mainOwners = {};
                for (const [tokenId, data] of Object.entries(mainTokens)) {
                  if (!(data.owner in mainOwners)) {
                    mainOwners[data.owner] = [];
                  }
                  mainOwners[data.owner].push(tokenId);
                }

                this.sync.completed = 0;
                const addresses = Object.keys(mainOwners);
                this.sync.total = addresses.length;
                this.sync.section = "ENS Names";
                const indexToName = {};
                for (let i = 0; i < addresses.length & !this.sync.halt; i += ENSOWNERBATCHSIZE) {
                  const batch = addresses.slice(i, parseInt(i) + ENSOWNERBATCHSIZE);
                  const allnames = await ensReverseRecordsContract.getNames(batch);
                  for (let j = 0; j < batch.length; j++) {
                    const address = batch[j];
                    const name = allnames[j];
                    indexToName[address] = name != null && name.length > 0 ? name : address;
                    // const normalized = normalize(address);
                  }
                  this.sync.completed = parseInt(this.sync.completed) + batch.length;
                }
                this.indexToName = indexToName;
                await db.cache.put({ objectName: 'indexToName', object: indexToName }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.mainToken.tokens = mainTokens;
                this.mainToken.owners = mainOwners;
                await db.cache.put({ objectName: 'mainToken', object: this.mainToken }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.secondaryData = {};
                await db.cache.put({ objectName: 'secondaryData', object: this.secondaryData }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
                this.sync.section = null;
              }

              if (action == "syncCollections") {
                console.log("syncCollections");
                let contracts = [];
                if (Object.keys(this.selectedCollections).length > 0) {
                  contracts = Object.keys(this.selectedCollections);
                } else {
                  for (const record of this.filteredSortedCollections) {
                    if (!(record.contract in this.secondaryData)) {
                      contracts.push(record.contract);
                    }
                  }
                }
                console.log("contracts: " + JSON.stringify(contracts));
                for (let contract of contracts) {
                  console.log("Processing: " + contract + " " + JSON.stringify(this.collections[contract]));

                  let continuation = null;
                  this.sync.completed = 0;
                  this.sync.total = null;
                  this.sync.section = this.collections[contract].name.substring(0, 24);
                  const tokens = {};
                  do {
                    let url = "https://api.reservoir.tools/tokens/v5?contract=" + contract + "&includeAttributes=false&limit=100" +
                      (continuation != null ? "&continuation=" + continuation : '');
                    console.log("url: " + url);
                    const data = await fetch(url)
                      .then(handleErrors)
                      .then(response => response.json())
                      .catch(function(error) {
                         console.log("ERROR - updateCollection: " + error);
                         // state.sync.error = true;
                         return [];
                      });
                    continuation = data.continuation;
                    if (data && data.tokens) {
                      for (const tokenData of data.tokens) {
                        const token = tokenData.token;
                        tokens[token.tokenId] = {
                          owner: token.owner,
                          image: token.image,
                        };
                      }
                    }
                    this.sync.completed = Object.keys(tokens).length;
                    await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  } while (continuation != null /*&& !this.sync.halt && !state.sync.error */);
                  Vue.set(this.collections[contract], 'tokens', tokens);
                  const owners = {};
                  for (const [tokenId, data] of Object.entries(tokens)) {
                    if (!(data.owner in owners)) {
                      owners[data.owner] = [];
                    }
                    owners[data.owner].push(tokenId);
                  }
                  Vue.set(this.collections[contract], 'owners', owners);
                  Vue.set(this.collections[contract], 'updated', timestamp);
                  Vue.set(this.collections[contract], 'blockNumber', blockNumber);
                }
                await db.cache.put({ objectName: 'collections', object: this.collections }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              if (action == "retrieveSecondaryCollection") {
                console.log("retrieveSecondaryCollection");
                let owners = [];
                if (Object.keys(this.selectedMainTable).length > 0) {
                  owners = Object.keys(this.selectedMainTable);
                } else {
                  for (const record of this.filteredSortedMainTable) {
                    if (!(record.owner in this.secondaryData)) {
                      owners.push(record.owner);
                    }
                  }
                }
                console.log("owners: " + JSON.stringify(owners));

                this.sync.completed = 0;
                this.sync.total = owners.count;
                this.sync.section = "Secondary collection";
                for (let owner of owners) {
                  console.log("Processing: " + owner);
                  Vue.set(this.secondaryData, owner, {});
                  let stop = false;
                  const LIMIT = 100;
                  const MAXLIMIT = 10000;
                  for (let offset = 0; offset < MAXLIMIT && !stop; offset = parseInt(offset) + LIMIT) {
                    let url = "https://api.reservoir.tools/users/" + owner + "/tokens/v5?sortBy=acquiredAt&sortDirection=desc&offset=" + offset + "&limit=" + LIMIT + "&includeTopBid=false";
                    console.log("url: " + url);
                    const data = await fetch(url)
                      .then(handleErrors)
                      .then(response => response.json())
                      .catch(function(error) {
                         console.log("ERROR - updateCollection: " + error);
                         // state.sync.error = true;
                         return [];
                      });
                    if (data && data.tokens && data.tokens.length > 0) {
                      for (const tokenData of data.tokens) {
                        const contract = tokenData.token.contract;
                        const tokenId = tokenData.token.tokenId;
                        const name = tokenData.token.name;
                        const image = tokenData.token.image;
                        const collectionName = tokenData.token.collection.name;
                        const collectionImage = tokenData.token.collection.imageUrl;
                        if (!(contract in this.secondaryData[owner])) {
                          Vue.set(this.secondaryData[owner], contract, {
                            collectionName,
                            collectionImage,
                            tokens: {},
                          });
                        }
                        Vue.set(this.secondaryData[owner][contract].tokens, tokenId, { tokenId, name, image });
                      }
                    } else {
                      stop = true;
                    }
                    await delay(1500); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  }
                  await delay(1000); // TODO: Adjust to avoid error 429 Too Many Requests. Fails at 200ms
                  this.sync.completed = parseInt(this.sync.completed) + 1;
                  if (this.sync.halt) {
                    break;
                  }
                }
                await db.cache.put({ objectName: 'secondaryData', object: this.secondaryData }).then (function() {
                }).catch(function(error) {
                  console.log("error: " + error);
                });
              }

              db.close();
              this.sync.section = null;
              this.sync.halt = false;
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          (async() => {
            await this.connectToWeb3();
          })();
          if ('cryptoPunksDataChainId' in localStorage) {
            this.chainId = localStorage.cryptoPunksDataChainId;
          }
          if ('cryptoPunksDataCoinbase' in localStorage) {
            this.coinbase = localStorage.cryptoPunksDataCoinbase;
          }
          if ('cryptoPunksDataSettings' in localStorage) {
            const tempSettings = JSON.parse(localStorage.cryptoPunksDataSettings);
            if ('version' in tempSettings && tempSettings.version == this.settings.version) {
              this.settings = tempSettings;
              if (this.settings.punksTable.currentPage > 1) {
                this.settings.punksTable.currentPage = 1;
              }
              if (this.settings.activityTable.currentPage > 1) {
                this.settings.activityTable.currentPage = 1;
              }
            }
          }
          (async() => {
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const blockTimestampsDataItems = await db.cache.where("objectName").equals('blockTimestamps').toArray();
            if (blockTimestampsDataItems.length == 1) {
              this.blockTimestamps = blockTimestampsDataItems[0].object;
            }
            await this.loadCurrentData(db);
            db.close();
          })();
        },
      })
    </script>
  </body>
</html>
